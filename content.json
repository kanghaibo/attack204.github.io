{"meta":{"title":"Attck204","subtitle":null,"description":"Dawn","author":"attack204","url":"https://blog.attack204.com"},"pages":[{"title":"bangumi","date":"2019-02-10T13:32:48.000Z","updated":"2019-02-26T01:30:22.007Z","comments":false,"path":"bangumi/index.html","permalink":"https://blog.attack204.com/bangumi/index.html","excerpt":"","text":"","keywords":null},{"title":"about","date":"2018-12-12T14:14:36.000Z","updated":"2019-02-26T01:30:22.005Z","comments":false,"path":"about/index.html","permalink":"https://blog.attack204.com/about/index.html","excerpt":"","text":"恭喜你发现了一只大菜鸡","keywords":"关于"},{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2019-02-26T01:30:22.012Z","comments":true,"path":"comment/index.html","permalink":"https://blog.attack204.com/comment/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》","keywords":"留言板"},{"title":"lab","date":"2019-01-05T13:47:59.000Z","updated":"2019-02-26T01:30:22.019Z","comments":false,"path":"lab/index.html","permalink":"https://blog.attack204.com/lab/index.html","excerpt":"","text":"sakura主题balabala","keywords":"Lab实验室"},{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2019-02-26T01:30:22.015Z","comments":false,"path":"donate/index.html","permalink":"https://blog.attack204.com/donate/index.html","excerpt":"","text":"","keywords":"谢谢饲主了喵~"},{"title":"client","date":"2018-12-20T15:13:35.000Z","updated":"2019-02-26T01:30:22.010Z","comments":false,"path":"client/index.html","permalink":"https://blog.attack204.com/client/index.html","excerpt":"","text":"直接下载 or 扫码下载：","keywords":"Android客户端"},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2019-02-26T01:30:22.025Z","comments":true,"path":"rss/index.html","permalink":"https://blog.attack204.com/rss/index.html","excerpt":"","text":""},{"title":"music","date":"2018-12-20T15:14:28.000Z","updated":"2019-02-26T01:30:22.023Z","comments":false,"path":"music/index.html","permalink":"https://blog.attack204.com/music/index.html","excerpt":"","text":"","keywords":"喜欢的音乐"},{"title":"tags","date":"2018-12-12T14:14:16.000Z","updated":"2019-02-26T01:30:22.028Z","comments":true,"path":"tags/index.html","permalink":"https://blog.attack204.com/tags/index.html","excerpt":"","text":""},{"title":"theme-sakura","date":"2019-01-04T14:53:25.000Z","updated":"2019-02-26T01:30:22.031Z","comments":false,"path":"theme-sakura/index.html","permalink":"https://blog.attack204.com/theme-sakura/index.html","excerpt":"","text":"Hexo主题Sakura修改自WordPress主题Sakura，感谢原作者Mashiro","keywords":"Hexo 主题 Sakura 🌸"},{"title":"links","date":"2018-12-19T15:11:06.000Z","updated":"2019-03-03T13:56:31.950Z","comments":true,"path":"links/index.html","permalink":"https://blog.attack204.com/links/index.html","excerpt":"","text":"","keywords":"友人帐"},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2019-02-26T01:30:22.033Z","comments":false,"path":"video/index.html","permalink":"https://blog.attack204.com/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番组计划 这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }","keywords":"B站"}],"posts":[{"title":"二次剩余Cipolla算法学习笔记","slug":"二次剩余Cipolla算法学习笔记","date":"2019-03-27T00:59:24.000Z","updated":"2019-03-27T01:00:42.000Z","comments":true,"path":"2019/03/27/二次剩余Cipolla算法学习笔记/","link":"","permalink":"https://blog.attack204.com/2019/03/27/二次剩余Cipolla算法学习笔记/","excerpt":"","text":"对于同余式 $$x^2 \\equiv n \\pmod p$$ 若对于给定的$n, P$，存在$x$满足上面的式子，则乘$n$在模$p$意义下是二次剩余，否则为非二次剩余 我们需要计算的是在给定范围内所有满足条件的$x$，同时为了方便，我们只讨论$p$是奇质数的情况 前置定理 $x^2 \\equiv (x+p)^2 \\pmod p$ 证明：$x^2 \\equiv x^2 + 2xp + p^2 \\pmod p$显然成立 对于$x^2 \\equiv n \\pmod p$，除$n=0$外，总共有$\\frac{p-1}{2}$个$n$使得该方程有解 我局的参考资料里对于这条性质的证明漏洞很大，所以下面的是自己yy的 根据第一个前置定理的式子，我们只需讨论$x \\in [1, p - 1]$即可(当$x=0$时对应了$n=0$的特殊情况) 一个显然的性质是 $$x^2 \\equiv (p - x)^2 \\pmod p$$ 那么当$x \\in [1, \\frac{p - 1}{2}]$我们可以取到所有解。 接下来我们只需要证明当$x\\in[1, \\frac{p-1}{2}]$时$x^2 \\bmod p$均两两不同 可以用反证法，若存在不同的$u, v$满足$u^2 \\equiv v^2 \\pmod p$ 那么有$(u + v)(u - v) \\equiv 0 \\pmod p$ 显然$-p &lt; u + v &lt; p$且$-p &lt; u - v &lt; p$且$u + v \\not = 0, u - v \\not = 0$，故该假设不成立，故原命题成立。 Q.E.D 勒让德符号(Legender symbol) 记 $$(\\frac{a}{p}) =\\begin{cases}1 , &amp;\\text{a在模$p$意义下是二次剩余}\\-1, &amp;\\text{a在模$p$意义下是非二次剩余}\\0, &amp;\\text{a mod p = 0}\\end{cases}$$ 这个东西的分布大概是这个样子 计算公式 我局的这个公式就是构造出来的 $$(\\frac{a}{p}) = a^{\\frac{p - 1}{2}} \\pmod p$$ 证明： 费马小定理：对于任意互质的$x, p$，有$x^{p - 1} = 1 \\pmod p$ 一条同余式的性质：若$a^k \\equiv b^k \\pmod p$，那么$a^{kx} \\equiv b^{xk} \\pmod p$ 然后直接把这玩意儿带到$x^2 \\equiv a \\pmod p$里就行了 这里简单的写一下: 首先要明确我们的目的，我们现在要验证这个公式的正确性，也就是说我们要证明当$a^{\\frac{p-1}{2}}=1 \\pmod p$时满足条件的$x$存在，当$a^{\\frac{p-1}{2}}= -1 \\pmod p$时$x$不存在，当$a^{\\frac{p-1}{2}}= 0 \\pmod p$时$a\\mod p = 0$ 当$a^{\\frac{p-1}{2}}=1 \\pmod p$时 我们假设有$x^2 \\equiv a \\pmod p$ $$x^{2\\frac{p-1}{2}} \\equiv a^{\\frac{p-1}{2}} \\pmod p$$ $$x^{p-1} \\equiv 1 \\pmod p$$ 根据费马小定理$x$显然存在，因此$a$是模$p$意义下的二次剩余 当$a^{\\frac{p-1}{2}}= -1 \\pmod p$时 假设有$x^2 \\equiv a \\pmod p$ 同理可知 $$x^{p-1} \\equiv -1 \\pmod p$$ 显然$x$不存在，因此$a$不是模$p$意义下的二次剩余 当$a^{\\frac{p-1}{2}}= 0 \\pmod p$时 显然有$a \\bmod p = 0$ Cipolla算法算法流程这个算法其实用两句话就能说完，但是背后的理论却非常高深(对于我这种菜鸡而言)。 首先使用随机的方法找到一个$(\\frac{a^2 - n}{p}) = -1$，记$\\omega = \\sqrt{a^2-n}$ 那么$x \\equiv (a + w)^{\\frac{p+1}{2}} \\pmod p$ 做完了。。。期望复杂度$O(\\log^2 n)$ 但是实际上实现起来并没有这么简单，因为要自定义类似于虚数的乘法/幂运算 算法理论首先要有一点抽代基础(群/环/域什么的要知道定义) 我们来逐步分析这个算法(按照我的叙述风格应该是从发明者的角度出发一步一步推出这玩意儿来，但是十分抱歉我实在是搞不明白他当时的脑回路qwq) 对于第一步，根据前面的定理，如果在$[1, p]$内随机，每次有$\\frac{1}{p}*\\frac{p-1}{2}$的概率找到一个解，那么期望步数大约为两次，因此复杂度是可以保证的。 但是找到这个东西有什么用呢？。如果我们把之前的数域记做$\\mathbf F_p$，$\\omega$在这个数域下是不能开根的，但是我们可以构造一个新的数域$\\mathbf F_p$，使得$\\omega$在$\\mathbf F_{p2}$下能够开根。类比于$-1$在复数域下能够表示为$\\sqrt{-1}$一样。 这样的话$\\mathbf F_{p2}$内的数都可以写作$a + k\\omega$的形式。可以证明这玩意儿确实是个合法的域，证明过程，同时也可以证明在$\\mathbf F_{p2}$下得到的解在$\\mathbf F_{p1}$下也成立，同时最后的答案中$\\omega$的系数一定为$0$ 现在来简单说明一下为什么$x \\equiv (a+\\omega)^{\\frac{p+1}{2}}$ 先来了解两个性质 $\\omega^p \\equiv -\\omega \\pmod p$ 证明：$$\\begin{aligned}\\omega^p &amp;= (a^2-n)^{\\frac{p}{2}}\\ &amp;= (a^2 - n)^{\\frac{p - 1}{2}} (a^2 - n)^{\\frac{1}{2}}\\ &amp;= -\\omega\\end{aligned}$$ $(a + b)^p \\equiv a^p + b^p \\pmod p$ 证明就直接考虑二项式定理中的组合数展开，发现除了第一项和最后一项之外都无法把$n!$消掉。 那么要证明$x \\equiv (a+\\omega)^{\\frac{p+1}{2}}$，实际上我们只需要证明$(a+\\omega)^{p+1}\\equiv n \\pmod p$就行了 $$\\begin{aligned} &amp;(a + \\omega)^{p + 1}\\=&amp;(a + \\omega)^p(a + \\omega)\\=&amp;(a - \\omega)(a + \\omega)(\\text{根据费马小定理$a^p \\equiv p \\pmod p$})\\=&amp;(a^2 - \\omega^2)\\=&amp;(a^2 - (a^2 - n))\\=&amp;n\\end{aligned}$$ 算法的大概思想就讲完了，下面煮个栗子~。 对于$x^2 \\equiv n \\pmod p$ 假设此时$p=13, n = 10$。 首先要找到一个$a$满足$(\\frac{a^ - 10}{13}) = -1$，然后脸黑的attack在经过1e9 +7次尝试后终于找到了一个$a =2$它满足条件，因为$(\\frac{7}{13}) = -1$此时$\\omega = \\sqrt{a^2 - n} = \\sqrt{-6}$ 按照老祖宗讲给我们的 $x \\equiv (2 + \\sqrt{-6})^{7} \\pmod {13}$ $$\\begin{aligned}&amp;\\left(2+{\\sqrt {-6}}\\right)^{2}=4+4{\\sqrt {-6}}-6=-2+4{\\sqrt {-6}}\\&amp;\\left(2+{\\sqrt {-6}}\\right)^{4}=\\left(-2+4{\\sqrt {-6}}\\right)^{2}=-1-3{\\sqrt {-6}}\\&amp;\\left(2+{\\sqrt {-6}}\\right)^{6}=\\left(-2+4{\\sqrt {-6}}\\right)\\left(-1-3{\\sqrt {-6}}\\right)=9+2{\\sqrt {-6}}\\&amp;\\left(2+{\\sqrt {-6}}\\right)^{7}=\\left(9+2{\\sqrt {-6}}\\right)\\left(2+{\\sqrt {-6}}\\right)=6.\\end{aligned}$$ 然后不难发现$36 \\equiv 10 \\pmod {13}$ 同时因为平方的性质，$-x$也是一个合法解，因此$-6 + 13 = 7$也是合法的 最后有一个小问题就是为什么最后$\\omega$的系数一定是$0$，参考资料中给出的解释我实在是不能理解，如果有看得懂的大佬欢迎给本菜鸡讲一下qwq 代码模板#include&lt;bits/stdc++.h&gt; using namespace std; const int mod = 13; namespace TwoRemain { template &lt;typename A, typename B&gt; inline int add(A x, B y) {if(x + y &lt; 0) return x + y + mod; return x + y &gt;= mod ? x + y - mod : x + y;} template &lt;typename A, typename B&gt; inline void add2(A &amp;x, B y) {if(x + y &lt; 0) x = x + y + mod; else x = (x + y &gt;= mod ? x + y - mod : x + y);} template &lt;typename A, typename B&gt; inline int mul(A x, B y) {return 1ll * x * y % mod;} template &lt;typename A, typename B&gt; inline void mul2(A &amp;x, B y) {x = (1ll * x * y % mod + mod) % mod;} int fmul(int a, int p, int Mod = mod) { int base = 0; while(p) { if(p &amp; 1) base = (base + a) % Mod; a = (a + a) % Mod; p &gt;&gt;= 1; } return base; } int fp(int a, int p, int Mod = mod) { int base = 1; while(p) { if(p &amp; 1) base = fmul(base, a, Mod); p &gt;&gt;= 1; a = fmul(a, a, Mod); } return base; } int f(int x) { return fp(x, (mod - 1) &gt;&gt; 1); } struct MyComplex { int a, b; int cn; MyComplex operator * (const MyComplex &amp;rhs) { return { add(fmul(a, rhs.a), fmul(cn, fmul(b, rhs.b, mod))), add(fmul(a, rhs.b), fmul(b, rhs.a)), cn }; } }; MyComplex fp(MyComplex a, int p) { MyComplex base = {1, 0, a.cn}; while(p) { if(p &amp; 1) base = base * a; a = a * a; p &gt;&gt;= 1; } return base; } int TwoSqrt(int n) { if(f(n) == mod - 1) return -1; if(f(n) == 0) return 0; int a = -1, val = -1; while(val == -1) { a = rand() &lt;&lt; 15 | rand(); val = add(mul(a, a), -n); if(f(val) != mod - 1) val = -1; } return fp({a, 1, val}, (mod + 1) / 2).a; } } using namespace TwoRemain; signed main() { cout &lt;&lt; TwoSqrt(10); return 0; } 参考资料二次剩余Cipolla算法学习小记 Legendre symbol","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.attack204.com/categories/算法/"},{"name":"二次剩余","slug":"算法/二次剩余","permalink":"https://blog.attack204.com/categories/算法/二次剩余/"},{"name":"Cipolla","slug":"算法/二次剩余/Cipolla","permalink":"https://blog.attack204.com/categories/算法/二次剩余/Cipolla/"}],"tags":[{"name":"数论","slug":"数论","permalink":"https://blog.attack204.com/tags/数论/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https://blog.attack204.com/categories/算法/"},{"name":"二次剩余","slug":"算法/二次剩余","permalink":"https://blog.attack204.com/categories/算法/二次剩余/"},{"name":"Cipolla","slug":"算法/二次剩余/Cipolla","permalink":"https://blog.attack204.com/categories/算法/二次剩余/Cipolla/"}]},{"title":"小学生都能看懂的生成函数入门教程","slug":"小学生都能看懂的生成函数入门教程","date":"2019-03-13T03:00:23.000Z","updated":"2019-03-13T03:01:53.550Z","comments":true,"path":"2019/03/13/小学生都能看懂的生成函数入门教程/","link":"","permalink":"https://blog.attack204.com/2019/03/13/小学生都能看懂的生成函数入门教程/","excerpt":"","text":"前言第一次当标题党真是有点不适应 现在网上讲生成函数的教程大多都是从$\\frac{1}{1-x} = \\sum_{i=0}^{\\infty}x^i, e^x = \\sum_{i=0}^{\\infty} \\frac{x^i}{i!}$开始，但是我不认为这样有助于大家理解生成函数的本质。我最开始学的时候也是在这里蒙了好久，直到看到了朱全明老师的课件，才真正的理解了生成函数的本质——处理排列组合问题的有利工具，而不是简单的$\\frac{1}{1-x}$的指标代换。所以这篇文章，我打算从最基本的排列组合问题写起，最后慢慢扩展到$\\frac{1}{1-x} = \\sum_{i=0}^{\\infty}x^i, e^x = \\sum_{i=0}^{\\infty} \\frac{x^i}{i!}$。内容会比较基础，高端玩家可以直接看鏼爷的集训队论文 生成函数定义维基百科上是这么定义的： 在数学中，某个序列$(a_n)_{n \\in \\mathbb{N}}$ 的母函数（又称生成函数，英语：Generating function）是一种形式幂级数，其每一项的系数可以提供关于这个序列的信息。 讲的通俗一点，对于某个序列${a_0, a_1, \\dots, a_n}$，我想找一个函数来表示它，假设是$G(x) = a_0 + a_1x + a_2x^2 \\dots a_n x^n$。这时候函数第$i$项的系数就表示了序列中的第$i$个元素。同时我们也可以看到，函数中的自变量$x$好像并没有什么意义，他的取值并不影响序列的表示，因此我们称这种函数为形式幂级数 用处那么这样定义由什么好处呢？ 我们仔细观察一下$G(x)$，不难发现这是一个多项式函数，对于多项式我们知道他有加、减、乘、除、求逆、取ln、exp等运算。那么我们对$G(x)$进行乘法运算，也就是相当于对序列进行乘法运算，那么这样干有什么意义呢？我们不妨从一个题目入手。 普通生成函数 有三种物品，分别有$3, 2, 3$个，问拿出$4$个进行组合$({1123}, {3211}$算一种)的方案数是多少 学过dp的人可能会一眼看出是背包板子题。直接设$f[i][j]$表示当前到第$i$个位置，已经选了$j$个物品的方案数。转移的时候枚举一下当前选了几个 f[0][0] = 1; for(int i = 1; i &lt;= 3; i++) for(int j = 0; j &lt;= 8; j++) //当前总共要选出j个 for(int k = 0; k &lt;= j; k++) //已经选了k个 if(j - k &lt;= v[i]) //此时要选j-k个 f[i][j] += f[i - 1][k]; 可以得到$f[3]$的系数为${1\\ 3\\ 6\\ 9\\ 10\\ 9\\ 6\\ 3\\ 1 }$(从0开始编号)，$4$最对应的一项是$10$。 那用生成函数怎么做呢？ 我们可以对每个物品构造一个多项式函数，其中第$i$项的系数$a_i$表示选了$i$个当前物品的方案数。 那么第一个物品的生成函数为$G_1(x) = 1 + x^1 + x^2 + x^3$ (相同的物品选$i$个的方案数当然是1) 第二个物品的生成函数为$G_2(x) = 1 + x^1 + x^2$ 第三个为$G_3(x) = 1 + x^1 + x^2 + x^3$ 先说结论：最终答案是$G_1(x) G_2(x) G_3(x)$的第$4$项的系数 这是为什么呢？考虑两个多项式相乘的结果$f* g$，它的第$k$项的系数为$\\sum_{i=0}^k f_i g_{k-i}$。这个过程是相当于是在枚举第一个物品选了几个，比如$4$这一项，他等于$f_0g_4 + f_1g_3 + f_2 g_2 + f_3g_1 + f_4g_0$。 再具体一点，抛开刚刚那个题目中系数等于$1$的限制，我们假设$f_1 = 2, g_3 = 3$，也就是说从第一个物品中选出$1$个有两种方案，第二个物品中选出$3$个有三种方案，那么$f_1 g_3=2 3$就相当于第一个物品的两种方案可以与第二个物品的三种方案任意组合来得到$4$种物品。(再看不懂的话建议去补一下高中组合计数qwq，这里讲的这么详细是为了给指数生成函数做铺垫) 这里建议大家去手玩一下多项式乘法，玩一下(玩的时候枚举$x^i$算他的系数)就会发现这个过程与背包的过程惊人的相似，因为事实上背包的过程就是在模拟多项式乘法。 这里为了下文(指数型生成函数)好讲解，本菜鸡直接把多项式相乘的结果(抄一下)写出来 $$\\begin{aligned}G(x) &amp;= (1+x+x^2+x^3)(1+x+x^2)(1+x+x^2+x^3) \\ &amp;= (1+2x+3x^2+3x^3+2x^4+x^5)(1+x+x^2+x^3)\\ &amp;=1+3x+6x^2+9x^3+10x^4+9x^5+6x^6+3x^7+x^8\\end{aligned}$$ 其中$x^4$项可以由下面这些得到，这种形式与我们的手玩结果就非常相似了 $$x_1x_3^3+x_2x_3^3+x_1^2x_3^2+x_1x_2x_3^2+x_2^2x_3^2+x_1^3x_3+x_1^2x_2x_3+x_1x_2^2x_3+x_1^3x_3+x_1^2x_2^2$$ 形如$G(x) = \\sum_{i=0}^n a_ix_i$的表示一个序列的多项式函数，我们称之为普通生成函数 讲到这里你需要大概明白：生成函数的基本概念，生成函数相乘的组合意义。 接下来按道理应该讲$\\frac{1}{1-x}$及其运算，但是我想先介绍一下指数生成函数的基本概念。 指数生成函数通过刚刚的讲解我们不难看出，普通生成函数的意义在于解决组合类计数问题。但是别忘了组合的兄弟排列呀。指数生成函数就是用来解决排列类问题。 还是刚刚的题目，我们改一下限制 有三种物品，分别有$3, 2, 3$个，问拿出$4$个进行组合$({1123}, {3211}$算不同方案)的方案数是多少(HDU1521) 这一类问题仅仅是比刚刚多了一个顺序的原因，但是难度却比刚刚大了不少(背包也可以做，只要在转移的时候乘一个组合数即可，留给大家思考) 这里先介绍一下多重集排列数 设$S = {a_1, a_2 \\dots a_n}, N = \\sum_{i=1}^n a_i$，其中第$a_i$表示第$i$个物品有$a_i$个。从中选出$N$个进行排列的方案数为$\\frac{N!}{a_1!a_2! \\dots a_n!}$解释的话就是相当于任意排列之后减去同种物品之间多出来的方案 这样我们就得到了一个思路：先把所有组合得到的方案算出来，然后再对每一种方案分别计算排列数，最后加起来。 比如我们刚刚已经得到了组合的方案： $$x_1x_3^3+x_2x_3^3+x_1^2x_3^2+x_1x_2x_3^2+x_2^2x_3^2+x_1^3x_3+x_1^2x_2x_3+x_1x_2^2x_3+x_1^3x_3+x_1^2x_2^2$$ 其中$x_1 x_3^3$这一项的排列方案就是$\\frac{4!}{1!3!}$，$x_1x_2x_3^2$这一项的排列方案就是$\\frac{4!}{1!1!2!}$。观察一下，所有方案的分子都是$4!$，分母都是选出来的对应数量的阶乘。 于是我们引进指数型生成函数 形如$G(x) = \\sum_{i=0}^n a_i \\frac{x_i}{i!}$的表示序列的多项式函数，我们称之为指数生成函数。 同时我们分别构造出$G_1(x) = 1+\\frac{x^1}{1} + \\frac{x^2}{2!} + \\frac{x^3}{3!}$ $G_2(x) = 1 + \\frac{x^1}{1} + \\frac{x^2}{2}$ $G_3(x) = 1 + \\frac{x^1}{1} + \\frac{x^2}{2!} + \\frac{x^3}{3!}$ 这时候再计算一下$G_1(x) G_2(x) G_3(x)$ $$\\begin{aligned}G_e(x) &amp;= (1 + \\frac{x}{1!} + \\frac{x^2}{2!} + \\frac{x^3}{3})(1+\\frac{x}{1!} + \\frac{x^2}{2!}) (1 + \\frac{x}{1!} + \\frac{x^2}{2!} + \\frac{x^3}{3!})\\ &amp;= (1+2x+2x^2+\\frac{7}{6}x^3 + \\frac{5}{12}x^4 + \\frac{1}{12}x^5) (1+x+\\frac{1}{2}x^2 + \\frac{1}{6}x^3)\\ &amp;=(1+3x + \\frac{9}{2}x^2 + \\frac{14}{3}x^3 + \\frac{35}{12}x^4 + \\frac{17}{12}x^5 + \\frac{35}{72} x^6 + \\frac{8}{72}x^7 + \\frac{1}{71}x^8)\\end{aligned}$$ 这时候如何计算选出$4$个物品的答案呢？简单$\\frac{35}{12} * 4! = 70$ 可能大家不禁思考，为什么这么定义函数乘起来就是排列数呢？想一想，因为我们对每个系数构造的$\\frac{1}{i!}$就相当于是多重集排列数中的分母呀 好了，如果你到这里都看懂了的话，说明你已经对生成函数有个大概的了解了。但是不知道大家是不是和我有着同样的感觉：生成函数好麻烦啊qwq。 那么有没有一套可以简化些运算的理论呢？ 答案是：当然有了！(不然我问个毛线)。下面讲的内容可以会有些刺激，需要大家有一定的数学基础(其实只要高中知识就行了) 普通生成函数的推广简单介绍这个也不能叫推广吧，是我自己瞎起的名字。。。 在我们刚刚的运算中出现了一个常用的函数$G(x) = \\sum_{i=0}^n x_i$，这个东西怎么化简呢？ 结论：$\\sum_{i=0}^{\\infty} x_i = \\frac{1}{1-x}$ 可能你和当初一次见到这个式子的我一样，大概是这个表情 我们来证明一下。 $S = 1 + x + x^2 + \\dots x^{\\infty}$ $xS = x + x^2 + x^3 + \\dots x^{\\infty}$ $S - xS = 1$ $S = \\frac{1}{1-x}$ 是不是证的天衣无缝但是又十分扯淡？因为这玩意儿显然只有$x^{\\infty}$收敛也就是$x\\in(-1, 1)$时成立。其实在这里只要在$x\\in(-1, 1)$成立就可以了，因为生成函数是形式幂级数，我们并不关心$x$的具体取值 有了这个我们能干什么呢？我们可以对$\\frac{1}{1-x}$变形来表示更多的序列，同时我们知道了$\\frac{1}{1-x}$对应序列的第$i$项的系数为$1$，那么当我们知道了某一个序列的生成函数之后我们也可以把它变成类似于$\\frac{1}{1-x}$的形式从而得到通项公式。 首先介绍一些简单的变换，建议大家手玩一下下面的生成函数的推广形式，比如把”乘$2$”换成”乘$k$” 将$x$替换为$-x$，$\\frac{1}{1+x} = {1, -1, 1, -1, \\dots}$ 将$x$替换为$2x$，$\\ \\frac{1}{1-2x} = {1, 2, 4, 8, 16, \\dots}$ 将$x$替换为$x^2$, $\\ \\ \\ \\frac{1}{1-x^2} = {1, 0, 1, 0, 1 \\dots}$ 将分母乘$2$, $\\ \\ \\ \\ \\quad\\frac{2}{1-x} = {2, 2, 2, 2, 2, \\dots}$ 将分子乘$x^3$, $\\ \\ \\quad \\frac{x^3}{1-x} \\ = {0, 0, 0, 1, 1, 1, 1 \\dots}$ 求个导, $\\qquad \\ \\ \\ \\ \\ \\frac{1}{(1-x)^2} = {1, 2, 3, 4, 5}$ 再求一次， $\\quad \\ \\ \\ \\frac{2}{(1-x)^3} ={2 + 6 + 12 + 20 \\dots}$ 问题来了，我如果知道了某一个数列的生成函数，怎么求它的通项公式呢？一般的思路就通过各种奇技淫巧往上面的几个生成函数转化。这里要提一下比较常用的广义二项式定理 $$\\frac{1}{(1-x)^n} = \\sum_{k=0}^{\\infty} C_{n+k-1}^{k-1} x^k$$ 我们来通过两个例子来具体讲一下它的用处 求斐波那契数列通项公式非常不不要脸的抄一下自己以前的博客 首先要知道斐波那契数列的递推式 $$f_i = f_{i-1} + f_{i - 2}$$ $$f_0 = f_1 = 1$$ 那么推导一下 设$A = 1 + 1x + 2x^2 + 3x^3 + 5x^4 + 8x^5 \\dots$ 根据递推式，我们可以这样变化，显然有 $$\\begin{aligned}A = \\ 1 + 1x + &amp;2x^2 + 3x^3 + 5x^4 + 8x^5 \\dots \\xA = \\ \\ \\qquad x + &amp;1x^2 + 2x^3 + 3x^4 + 5x^5\\dots \\x^2A =\\qquad \\qquad &amp;1x^2 + 1x^3 + 2x^4 + 3x^5 \\dots\\end{aligned}$$ 那么可以得到一个方程$A - xA - x^2A = 1$ 整理一下$A =\\frac{1}{1-x-x^2}$ 这样我们就得到了斐波那契数列的生成函数，然而并没有什么卵用，因为我们不能直接通过观察看出每一项的系数。 现在考虑一下，我们接下来可以干什么。我们已经知道了$\\frac{1}{1-x}$和$\\frac{1}{1-kx}$所表示的序列。接下来要干的当然是把$\\frac{1}{1-x-x^2}$往上面的两个式子转化。 $\\frac{1}{1-x-x^2}$这玩意儿下半部分是个一元二次方程，我们可以配方 $$1-x-x^2 = (1-\\phi_1x)(1-\\phi_2x)$$ $$\\phi_1 = \\frac{1+\\sqrt{5}}{2}, \\phi_2 = \\frac{1-\\sqrt{5}}{2}$$ (解的时候可以直接把后面的式子拆开，把这两个式子对应项联立组成方程组, $\\phi_1 \\phi_2$的取值是可以反过来的) 这个时候我们发现已经找到与$\\frac{1}{1-kx}$的联系了，我们可以把$\\frac{1}{(1-\\phi_1 x)(1-\\phi_2 x)}$拆成求和的形式。可以裂一下项 原式变为$\\frac{a}{1-\\phi_1x} + \\frac{b}{1-\\phi_2 x}$，然后再解一个方程$a(1-\\phi_2 x) + b(1-\\phi_1x) = 1$ 解这个方程就没那么休闲了，这里我们选择把$x$当做主元对方程进行变换 $$(a+b - 1) - x(a\\phi_2 + b\\phi_1) = 0 $$ 这样就好处理了，只要列个二元一次方程组 $$\\begin{cases}a-b-1 = 0\\a\\phi_2 + b\\phi_1 = 0\\end{cases}$$ 解一下可以得到$a = \\frac{1}{\\sqrt{5}} \\phi_1, b = -\\frac{1}{\\sqrt{5}} \\phi_2$ 带回去 $$A = \\frac{\\phi_1}{\\sqrt{5}} \\frac{1}{1-\\phi_1x} - \\frac{\\phi_2}{\\sqrt{5}} \\frac{1}{1-\\phi_2x}$$ 那么第$n$项的公式为 $$A_n = \\frac{1}{\\sqrt{5}} ((\\frac{1+\\sqrt{5}}{2})^{n+1} - (\\frac{1-\\sqrt{5}}{2})^{n+1})$$ 解决组合类问题比如这种休闲板子题 至多为$k$就是$\\frac{1-x^{k+1}}{1-x}$ $k$的倍数就是$\\frac{1}{1-x^k}$ 化简完了就只剩下一个$\\frac{1}{(1-x)^5}$ 这个东西可以直接广义二项式定理展开，然后交一发pypy2就过了。。 指数生成函数的推广和上面的很类似，这里直接说结论 $$e^x = \\sum_{i=0}^{\\infty} \\frac{x^i}{i!}$$ 证明考虑直接将$e^x$在$x = 0$处泰勒展开由泰勒展开的公式$f(x) = f(x_0) + \\frac{f^1(x_0)}{1} (x-x_0) + \\frac{f^2(x_0)}{2!} (x-x_0)^2 + \\dots + \\frac{f^n(x0)}{n} (x-x_0)^n \\xi$ ($f^n$的意思是求$n$次导数)可以直接得到。 一些常用变换 $e^{-x} = 1 - \\frac{x}{1} + \\frac{x}{2!} -\\frac{x}{3!} + \\frac{x}{4!}\\dots$ $\\frac{e^x + e^{-x}}{2} = 1 + \\frac{x^2}{2!} + \\frac{x^4}{4!} + \\frac{x^6}{6!}\\dots$ $\\frac{e^x - e^{-x}}{2} = \\frac{x}{1} + \\frac{x^3}{3!} + \\frac{x^5}{5!} + \\frac{x^7}{7!}$ $e^{kx} = 1 + \\frac{x}{1} + \\frac{k^2x^2}{2!} + \\frac{k^3x^3}{3!} + \\frac{k^4x^4}{4!} \\dots$ 一道简单的题目长度为$n$的序列，用红黄蓝绿四种颜色染色，其中红黄只能是偶数，问方案数 $n \\leqslant 10^9$ 这道题就比较休闲了 任意的是$e^x$，偶数的是$\\frac{e^x + e^{-x}}{2}$ 最后化完是$\\frac{e^{4x} + 2e^{2x}+1}{4} = \\frac{4^n+2 * 2^{n+1}}{4}$($\\frac{1}{4}$)相当于常数项 直接快速幂就可以求 后记本篇讲的是关于生成函数最基础的内容，千万不要认为自己看懂了上面的内容就会生成函数了，充其量也就是了解而已。生成函数理论十分博大精深，我也只是略知皮毛。过几天可能会根据学习情况更一些生成函数与多项式运算的东西，敬请期待吧qwq 参考资料生成函数-罗煜楚(版权原因暂不公开) 组合数学—母函数与递推——朱全民 母函数——维基百科","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://blog.attack204.com/categories/学习笔记/"},{"name":"算法","slug":"学习笔记/算法","permalink":"https://blog.attack204.com/categories/学习笔记/算法/"}],"tags":[{"name":"生成函数","slug":"生成函数","permalink":"https://blog.attack204.com/tags/生成函数/"}],"keywords":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://blog.attack204.com/categories/学习笔记/"},{"name":"算法","slug":"学习笔记/算法","permalink":"https://blog.attack204.com/categories/学习笔记/算法/"}]},{"title":"利用生成函数求斐波那契数列通项公式","slug":"利用生成函数求斐波那契数列通项公式","date":"2019-03-11T12:29:30.000Z","updated":"2019-03-11T12:30:40.273Z","comments":true,"path":"2019/03/11/利用生成函数求斐波那契数列通项公式/","link":"","permalink":"https://blog.attack204.com/2019/03/11/利用生成函数求斐波那契数列通项公式/","excerpt":"","text":"利用生成函数求斐波那契数列通项公式先吐槽一下，学习这玩意儿的时候真的是深深的明白了自己的弱小，人家的一个”解得”我居然解了两个小时。。qwq 前置知识斐波那契数列：$$f_i = f_{i-1} + f_{i - 2}$$ $$f_0 = f_1 = 1$$ 普通生成函数:简单来说用多项式$\\sum_{i=0}^{\\infty} a_ix^i$的系数表示序列的元素 同时因为我们不关心$x$的取值，因此$\\sum_{i=0}^{\\infty}a_ix^i$又称作以$x$为自由元的形式幂级数 常见的有:$\\frac{1}{1-x} = 1 + x + x^2 + x^3 + \\dots + x^{\\infty}$ 证明:后半部分可以直接由通项公式得到$S_n = \\frac{1-x^{n+1}}{1-x}$，当$x \\in (-1, 1)$，那么$\\lim_{n\\to +\\infty} x^{n+1} = 0$ 将$x$替换为$xk$得 $\\frac{1}{1-kx} = 1 + kx + k^2x^2 + k^3x^3 \\dots + k^{\\infty}x^{\\infty}$ 解法设$A = 1 + 1x + 2x^2 + 3x^3 + 5x^4 + 8x^5 \\dots$ 根据递推式，我们可以这样变化，显然有 $$\\begin{aligned}A = \\ 1 + 1x + &amp;2x^2 + 3x^3 + 5x^4 + 8x^5 \\dots \\xA = \\ \\ \\qquad x + &amp;1x^2 + 2x^3 + 3x^4 + 5x^5\\dots \\x^2A =\\qquad \\qquad &amp;1x^2 + 1x^3 + 2x^4 + 3x^5 \\dots\\end{aligned}$$ 那么可以得到一个方程$A - xA - x^2A = 1$ 整理一下$A =\\frac{1}{1-x-x^2}$ 这样我们就得到了斐波那契数列的生成函数，然而并没有什么卵用，因为我们不能直接通过观察看出每一项的系数。 现在考虑一下，我们接下来可以干什么。我们已经知道了$\\frac{1}{1-x}$和$\\frac{1}{1-kx}$所表示的序列。接下来要干的当然是把$\\frac{1}{1-x-x^2}$往上面的两个式子转化。 $\\frac{1}{1-x-x^2}$这玩意儿下半部分是个一元二次方程，我们可以配方 $$1-x-x^2 = (1-\\phi_1x)(1-\\phi_2x)$$ $$\\phi_1 = \\frac{1+\\sqrt{5}}{2}, \\phi_2 = \\frac{1-\\sqrt{5}}{2}$$ (解的时候可以直接把后面的式子拆开，把这两个式子对应项联立组成方程组, $\\phi_1 \\phi_2$的取值是可以反过来的) 这个时候我们发现已经找到与$\\frac{1}{1-kx}$的联系了，我们可以把$\\frac{1}{(1-\\phi_1 x)(1-\\phi_2 x)}$拆成求和的形式。可以裂一下项 原式变为$\\frac{a}{1-\\phi_1x} + \\frac{b}{1-\\phi_2 x}$，然后再解一个方程$a(1-\\phi_2 x) + b(1-\\phi_1x) = 1$ 解这个方程就没那么休闲了，这里我们选择把$x$当做主元对方程进行变换 $$(a+b - 1) - x(a\\phi_2 + b\\phi_1) = 0 $$ 这样就好处理了，只要列个二元一次方程组 $$\\begin{cases}a-b-1 = 0\\a\\phi_2 + b\\phi_1 = 0\\end{cases}$$ 解一下可以得到$a = \\frac{1}{\\sqrt{5}} \\phi_1, b = -\\frac{1}{\\sqrt{5}} \\phi_2$ 带回去 $$A = \\frac{\\phi_1}{\\sqrt{5}} \\frac{1}{1-\\phi_1x} - \\frac{\\phi_2}{\\sqrt{5}} \\frac{1}{1-\\phi_2x}$$ 那么第$n$项的公式为 $$A_n = \\frac{1}{\\sqrt{5}} ((\\frac{1+\\sqrt{5}}{2})^{n+1} - (\\frac{1-\\sqrt{5}}{2})^{n+1})$$ 参考资料生成函数-罗煜楚(版权原因暂不公开) 特别感谢张一钊老师qwq","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://blog.attack204.com/categories/学习笔记/"},{"name":"算法竞赛","slug":"学习笔记/算法竞赛","permalink":"https://blog.attack204.com/categories/学习笔记/算法竞赛/"}],"tags":[{"name":"生成函数","slug":"生成函数","permalink":"https://blog.attack204.com/tags/生成函数/"},{"name":"斐波那契数","slug":"斐波那契数","permalink":"https://blog.attack204.com/tags/斐波那契数/"}],"keywords":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://blog.attack204.com/categories/学习笔记/"},{"name":"算法竞赛","slug":"学习笔记/算法竞赛","permalink":"https://blog.attack204.com/categories/学习笔记/算法竞赛/"}]},{"title":"js中mousedown/up与click的关系","slug":"js中mousedown-up与click的关系","date":"2019-03-01T09:39:44.000Z","updated":"2019-03-01T09:49:50.796Z","comments":true,"path":"2019/03/01/js中mousedown-up与click的关系/","link":"","permalink":"https://blog.attack204.com/2019/03/01/js中mousedown-up与click的关系/","excerpt":"","text":"mousedown/mouseup与click的关系三者都是在鼠标点击时触发的时间，但是触发时间和触发方式有所不同 mousedown当鼠标指针移动到元素上方，并按下鼠标按键(左右按键)时即可触发。 mousedown当鼠标指针松开(左右键均可)时触发 click当鼠标指针停留在元素上方，然后按下并松开鼠标左键时触发 需要注意的是，不论mousedown还是click，若鼠标移开了当前元素，则均不会触发 三个事件的触发顺序若在同一个元素上按下并松开鼠标左键，会依次触发mousedown、mouseup、click，前一个事件执行完毕才会执行下一个事件 若在同一个元素上按下并松开鼠标右键，会依次触发mousedown、mouseup，前一个事件执行完毕才会执行下一个事件，不会触发click事件","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://blog.attack204.com/categories/学习笔记/"},{"name":"JavaScript","slug":"学习笔记/JavaScript","permalink":"https://blog.attack204.com/categories/学习笔记/JavaScript/"}],"tags":[{"name":"JQuery","slug":"JQuery","permalink":"https://blog.attack204.com/tags/JQuery/"}],"keywords":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://blog.attack204.com/categories/学习笔记/"},{"name":"JavaScript","slug":"学习笔记/JavaScript","permalink":"https://blog.attack204.com/categories/学习笔记/JavaScript/"}]},{"title":"类欧几里得算法学习笔记","slug":"类欧几里得算法学习笔记","date":"2019-02-26T03:39:59.000Z","updated":"2019-02-26T03:41:56.313Z","comments":true,"path":"2019/02/26/类欧几里得算法学习笔记/","link":"","permalink":"https://blog.attack204.com/2019/02/26/类欧几里得算法学习笔记/","excerpt":"","text":"类欧几里得算法这种东西。。。了解了解愉悦一下身心吧。只学了最简单的一种，其他的一坨扩展等哪天心情好了再看。 设$f(n, a, b, c) = \\sum_{i=0}^n \\lfloor \\frac{ai + b}{c} \\rfloor$ 我们要计算的就是$f(n, a, b, c)$，如果认为$n, a, b, c$同阶的话，我们可以做到$\\log n$的复杂度 前置知识一些关于取整的小结论 $a &lt; \\lfloor \\frac{b}{c} \\rfloor \\Leftrightarrow ac &lt; b$ $a &gt; \\lceil \\frac{b}{c} \\rceil \\Leftrightarrow ac &gt; b$ $a \\leqslant \\lfloor \\frac{b}{c} \\rfloor \\Leftrightarrow ac \\leqslant b$ $a \\geqslant \\lceil \\frac{b}{c} \\rceil \\Leftrightarrow ac \\geqslant b$ $\\lfloor \\frac{b}{c} \\rfloor = \\lceil \\frac{b-c+1}{c} \\rceil$ $\\lceil \\frac{b}{c} \\rceil = \\lfloor \\frac{b+c-1}{c} \\rfloor$ 然后就可以推柿子啦 神仙推导$$\\begin{aligned}f(n, a, b, c) &amp;=\\sum_{i=0}^n \\lfloor \\frac{ai + b}{c} \\rfloor\\ &amp;=\\sum_{i=0}^{n} \\sum_{j=0}^{\\lfloor \\frac{ai + b}{c} \\rfloor - 1} 1 \\ &amp;=\\sum_{j=0}^{\\lfloor \\frac{an+b}{c} \\rfloor -1} \\sum_{i=0}^n (j &lt; \\lfloor \\frac{ai+b}{c} \\rfloor)\\ &amp;=\\sum_{j=0}^{\\lfloor \\frac{an+b}{c} \\rfloor -1} \\sum_{i=0}^n (j &lt; \\lceil \\frac{ai+b-c+1}{c})\\ &amp;=\\sum_{j=0}^{\\lfloor \\frac{an+b}{c} \\rfloor -1} \\sum_{i=0}^n (cj &lt; ai + b - c + 1)\\ &amp;=\\sum_{j=0}^{\\lfloor \\frac{an+b}{c} \\rfloor -1} \\sum_{i=0}^n (i &gt; \\lfloor \\frac{cj-b+c-1}{a} \\rfloor)\\ &amp;=\\sum_{j=0}^{\\lfloor \\frac{an+b}{c} \\rfloor -1} n - \\lfloor \\frac{cj-b+c-1}{a} \\rfloor\\ &amp;=n \\lfloor \\frac{an+b}{c} \\rfloor - \\sum_{j=0}^{\\lfloor \\frac{an+b}{c} \\rfloor -1} \\lfloor \\frac{cj-b+c-1}{a} \\rfloor\\ &amp;=n \\lfloor \\frac{an+b}{c} \\rfloor - f(\\lfloor \\frac{an+b}{c} \\rfloor -1, c, c-b-1, a)\\end{aligned}$$ 然后就能递归算了，每次范围会至少折半，因此复杂度为$\\log n$","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://blog.attack204.com/categories/学习笔记/"},{"name":"oi","slug":"学习笔记/oi","permalink":"https://blog.attack204.com/categories/学习笔记/oi/"}],"tags":[{"name":"类欧几里得算法","slug":"类欧几里得算法","permalink":"https://blog.attack204.com/tags/类欧几里得算法/"}],"keywords":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://blog.attack204.com/categories/学习笔记/"},{"name":"oi","slug":"学习笔记/oi","permalink":"https://blog.attack204.com/categories/学习笔记/oi/"}]},{"title":"线性代数学习笔记","slug":"线性代数学习笔记","date":"2019-02-24T04:37:01.000Z","updated":"2019-02-26T01:30:22.003Z","comments":true,"path":"2019/02/24/线性代数学习笔记/","link":"","permalink":"https://blog.attack204.com/2019/02/24/线性代数学习笔记/","excerpt":"","text":"矩阵$A_{nm}$表示一个$n$行$m$列的矩阵。 一个$1$行$n$列的矩阵可以被称为行向量 一个$n$行$1$列的矩阵可以被称为列向量 一个$n$行$n$列的矩阵可以被称为$n$阶方阵$A_n$ $A^T$表示矩阵的转置，即$a_{ij}^{T} = a_{ji}$，相当于把矩阵沿主对角线翻转 除了主对角线上的元素全部为$0$的矩阵为对角矩阵 主对角线以下全部为$0$的方阵是上三角矩阵 单位矩阵是主对角线全为$1$的对角矩阵，一般用$I/E$表示 逆矩阵矩阵$A$的逆矩阵$A^{-1}$，是满足$AA^{-1} = A^{-1}A = I$的矩阵 求逆矩阵的方法： 将原矩阵的右边放一个单位矩阵，并对整体进行消元，当左边被消成单位矩阵时，右侧就被消成了逆矩阵。如果中途失败则说明矩阵不可逆 其实还好理解，消元过程中使用的矩阵初等行变换实际上是左乘一个矩阵，他们的乘积就是逆矩阵，因此我们需要在右侧来构造一个矩阵来收集乘积的结果。 行列式定义一个方阵的行列式表示为$|A|$ $$|A| = \\sum_{p}(-1)^{\\sigma(p)} \\prod_{i = 1}^n a_{i, p_i}$$ 其中$p$表示任意一个$1$到$n$的排列 $\\sigma(p)$表示$p$的逆序对的数量 比如当$n = 2$时， $$\\begin{vmatrix} a_{11} &amp; a_{12} \\ a_{21} &amp; a_{12} \\end{vmatrix}=a_{11}a_{22}-a_{12}a_{21} $$ 解释一下 当$p = 1,2$时，逆序对为$0$个，$p_1 = 1, p_2 = 2$，因此$(-1)^0 (a_{1_{p_1}})(a_{2_{p_2}}) = a_{11} * a_{22}$ 当$p = 2,1$时，逆序对为$1$个，$p_1 = 2, p_2 = 1$，因此$(-1)^1 (a_{1_{p_1}})(a_{2_{p_2}}) = -1 a_{12} a_{21}$ 因此$|A| = a_{11}{22} - a_{12}a_{21}$ 性质 一个对角矩阵/上三角矩阵的行列式值是所有对角线上元素的乘积 证明： 大概感性的理解一下吧，考虑行列式的定义中，我们需要枚举$a_{i{p_i}}$，那么当$i = n$(也就是最后一行)，我们只有一种取值($p_n = n$)不为$0$， 当$i = n - 1$时，虽然有两种取值，但是最后一行已经去了一种，因此还是只有一种取值，以此类推。每一行都只有一种取值 因此答案为对角线元素的乘积 交换矩阵的两行/两列，行列值取反 证明： 性质：对于一个排列，交换任意两个元素，排序的奇偶性一定改变 我们交换了两行/两列，实际上是交换了$p_i, p_j$，因此奇偶性一定改变。 将矩阵的一行/一列乘上一个固定的常数$k$，行列式值也乘上$k$ 将矩阵的一行加到另外一行上去，行列式值不变，列同理 证明： 想要直接证明比较困难，我们先证几个性质 存在两行一样的矩阵，行列式值为$0$ 证明：考虑，如果第$x$行和第$y$行相同，那么交换排列中的$p_x, p_y$，$\\prod a_{i, p_i}$不变，而前面的符号相反。所以行列式的每一项都存在一项和它的绝对值相同，符号相反 假设矩阵第$x$行，第$i$列的元素为$a_{i}$，且满足$a_i = b_i + c_i$，那么我们一定可以构造两个矩阵$B,C$，使得$|A| = |B| + |C|$ 有了这两个性质，再重新考虑我们需要证明的东西 一个行$a$加到另一行$b$上面，我们会得到一行$c = a+b$ 我们可以把$c$拆开来看，其中的$b$已经出现过，因此它对答案的贡献为$0$ 所以行列值的值不变 矩阵可逆的充要条件是行列式不为$0$ 证明： 行列式为$0$，说明消元过程中出现了$a_{i, j} = 0$ 有了这些性质，我们就可以用高斯消元在$O(n^3)$的时间复杂度内求出矩阵行列式的值 伴随矩阵余子式：将方阵的第$i$行和第$j$行同时划去，剩余的一个$n - 1$阶的矩阵的行列式值称为元素$a_{ij}$的余子式，通常记为$M_{ij}$ 代数余子式：元素$a_{ij}$的代数余子式为$C_{ij} = (-1)^{i + j} M_{ij}$ 拉普拉斯展开对于一个方阵$A$，$A$的行列式等于某一行所有元素的值乘上他们代数余子式 的和 即:$|A| = \\sum_{i = 1}^n a_{xi} C_{xi}$，$x$是一个确定的行坐标，列同理 伴随矩阵矩阵$A$的代数余子式矩阵是有每个元素的代数余子式构成的矩阵 矩阵$A$的伴随矩阵$A$，是$A$的代数余子式矩阵的转置，即$A = C^T$ 对于可逆矩阵，满足 $A* = |A|A^{-1}$ 其他的一些定义线性空间线性空间：一个非空集合$V$，对加法满足阿贝尔群，对数乘满足结合律，分配律，封闭性，域$F$上的单位元$1$满足$1v = v$ 子空间：设$W$是$V$的一个子集，$W$在加法和数乘下都是封闭的，且$0 \\in W$，则$W$是$V$的子空间 生成子空间(扩张)：对于若干$V$中的元素$v$，包含这些$v$的最小的子空间$W$是这些元素的生成子空间 生成集合：对于一个$V$的子集$v$，如果$v$的生成子空间是$V$，则称$v$是$V$的一个生成集合 线性相关对于一个线性空间的一个子集$v_1, v_2, \\dots , v_k$，如果$x_1v1 + x_2v_2 + \\dots x_kv_k = 0$存在非平凡解，则称这个子集线性相关，否则线性无关。这个条件等价于：任何一个元素都可以被其他元素线性表出 对于向量空间$V$的一个线性无关子集$v$，如果$v$的生成子空间是$V$，则称$v$是$V$的一组基，$|v|$是$V$的维度，同时$v$也是$V$的最小生成集合，同时也是极大线性无关组 对于一个矩阵$A$，把它的每一行看做一个行向量，那么它的极大线性无关组大小称为$A$的行秩，同理也可以定义$A$的列秩。显然，一个矩阵的行秩和列秩是相等的，如果一个矩阵的秩等于它的阶，那么这个矩阵满秩 同样，一个矩阵可逆的条件等于矩阵满秩。 反证法：如果矩阵不满秩，则消到最后一行时，一定可以被之间的线性表出","categories":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://blog.attack204.com/categories/算法竞赛/"},{"name":"学习笔记","slug":"算法竞赛/学习笔记","permalink":"https://blog.attack204.com/categories/算法竞赛/学习笔记/"}],"tags":[{"name":"线性代数","slug":"线性代数","permalink":"https://blog.attack204.com/tags/线性代数/"},{"name":"数学","slug":"数学","permalink":"https://blog.attack204.com/tags/数学/"}],"keywords":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://blog.attack204.com/categories/算法竞赛/"},{"name":"学习笔记","slug":"算法竞赛/学习笔记","permalink":"https://blog.attack204.com/categories/算法竞赛/学习笔记/"}]},{"title":"拉格朗日插值学习笔记","slug":"拉格朗日插值学习笔记","date":"2019-02-24T04:32:18.000Z","updated":"2019-02-26T01:30:21.990Z","comments":true,"path":"2019/02/24/拉格朗日插值学习笔记/","link":"","permalink":"https://blog.attack204.com/2019/02/24/拉格朗日插值学习笔记/","excerpt":"","text":"简介 在数值分析中，拉格朗日插值法是以法国18世纪数学家约瑟夫·拉格朗日命名的一种多项式插值方法。如果对实践中的某个物理量进行观测，在若干个不同的地方得到相应的观测值，拉格朗日插值法可以找到一个多项式，其恰好在各个观测的点取到观测到的值。上面这样的多项式就称为拉格朗日（插值）多项式。 拉格朗日插值法众所周知，$n + 1$个$x$坐标不同的点可以确定唯一的最高为$n$次的多项式。在算法竞赛中，我们常常会碰到一类题目，题目中直接或间接的给出了$n+1$个点，让我们求由这些点构成的多项式在某一位置的取值 一个最显然的思路就是直接高斯消元求出多项式的系数，但是这样做复杂度巨大$(n^3)$且根据算法实现不同往往会存在精度问题 而拉格朗日插值法可以在$n^2$的复杂度内完美解决上述问题 假设该多项式为$f(x)$, 第$i$个点的坐标为$(x_i, y_i)$，我们需要找到该多项式在$k$点的取值 根据拉格朗日插值法 $$f(k) = \\sum_{i = 0}^{n} y_i \\prod_{i \\not = j} \\frac{k - x[j]}{x[i] - x[j]}$$ 乍一看可能不是很好理解，我们来举个例子理解一下 假设给出的三个点为$(1, 3)(2, 7)(3, 13)$ 直接把$f(k)展开$ $f(k) = 3 \\frac{(k - 2)(k - 3)}{(1 - 2)(1 - 3)} + 7\\frac{(k-1)(k-2)}{(2 - 1)(2-3)} + 13\\frac{(k-1)(k-2)}{(3 -1)(3-2)}$ 观察不难得到，如果我们把$x_i$带入的话，除第$i$项外的每一项的分子中都会有$x_i - x_i$，这样其他的所有项就都被消去了 因此拉格朗日插值法的正确性是可以保证的 下面说一下拉格朗日插值法的拓展 在$x$取值连续时的做法在绝大多数题目中我们需要用到的$x_i$的取值都是连续的，这样的话我们可以把上面的算法优化到$O(n)$复杂度 首先把$x_i$换成$i$，新的式子为 $f(k) = \\sum_{i=0}^n y_i \\prod_{i \\not = j} \\frac{k - j}{i - j}$ 考虑如何快速计算$\\prod_{i \\not = j} \\frac{k - j}{i - j}$ 对于分子来说，我们维护出关于$k$的前缀积和后缀积，也就是 $$pre_i = \\prod_{j = 0}^{i} k - j$$ $$suf_i = \\prod_{j = i}^n k - j$$ 对于分母来说，观察发现这其实就是阶乘的形式，我们用$fac[i]$来表示$i!$ 那么式子就变成了 $$f(k) = \\sum_{i=0}^n y_i \\frac{pre_{i-1} suf_{i+1}}{fac[i] fac[N - i]}$$ 注意:分母可能会出现符号问题，也就是说，当$N - i$为奇数时，分母应该取负号 重心拉格朗日插值法再来看一下前面的式子 $$f(k) = \\sum_{i = 0}^{n} y_i \\prod_{i \\not = j} \\frac{k - x[j]}{x[i] - x[j]}$$ 设$g = \\prod_{i=1}^n k - x[i]$ $$f(k) = g\\sum_{i = 0}^{n} \\prod_{i \\not = j} \\frac{y_i}{(k - x[i])(x[i] - x[j])}$$ 设$t_i = \\frac{y_i}{\\prod_{j \\not =i} x_i - x_j}$ $$f(k) = g\\sum_{i = 0}^{n} \\frac{t_i}{(k - x[i])}$$ 这样每次新加入一个点的时候只需要计算它的$t_i$即可 应用经典应用首先讲一个经典应用：计算$\\sum_{i=1}^n i^k (n \\leqslant 10^{15}, k \\leqslant 10^6)$ 老祖宗告诉我们，这个东西是个以$n$为自变量的$k + 1$次多项式，具体证明可以看第二份参考资料 然后直接带入$k+1$个点后用拉格朗日插值算即可，复杂度$O(k)$ 那具体在题目中怎么使用拉格朗日插值呢？ 首先你要证明求的东西是某个多项式，判断的依据是： 大部分情况下归纳一下就可以了 题目由易到难排列 洛谷P4593 [TJOI2018]教科书般的亵渎 BZOJ3453: tyvj 1858 XLkxc BZOJ4559: [JLoi2016]成绩比较 BZOJ2655: calc 参考资料拉格朗日插值法 差分的应用及正整数的k次方幂求和 拉格朗日插值法及应用 拉格朗日插值 学习笔记","categories":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://blog.attack204.com/categories/算法竞赛/"},{"name":"学习笔记","slug":"算法竞赛/学习笔记","permalink":"https://blog.attack204.com/categories/算法竞赛/学习笔记/"}],"tags":[{"name":"拉格朗日插值","slug":"拉格朗日插值","permalink":"https://blog.attack204.com/tags/拉格朗日插值/"},{"name":"多项式","slug":"多项式","permalink":"https://blog.attack204.com/tags/多项式/"}],"keywords":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://blog.attack204.com/categories/算法竞赛/"},{"name":"学习笔记","slug":"算法竞赛/学习笔记","permalink":"https://blog.attack204.com/categories/算法竞赛/学习笔记/"}]},{"title":"Lyndon Word学习笔记","slug":"Lyndon-Word学习笔记","date":"2019-02-24T04:28:06.000Z","updated":"2019-02-26T01:30:21.960Z","comments":true,"path":"2019/02/24/Lyndon-Word学习笔记/","link":"","permalink":"https://blog.attack204.com/2019/02/24/Lyndon-Word学习笔记/","excerpt":"","text":"Lyndon Word定义：对于字符串$s$，若$s$的最小后缀为其本身，那么称$s$为Lyndon串 等价性：$s$为Lyndon串等价于$s$本身是其循环移位中最小的一个 性质任意字符串$s$都可以分解为$s = s_1 s_2 \\dots s_k$，其中$\\forall s_i$为Lyndon串且$s_i \\geqslant s_{i +1}$。且这种分解方法是唯一的 存在性 引理1：若$u, v$为Lyndon串，且$u &lt; v$，那么$uv$为Lyndon串 证明：要证明$uv$为Lyndon串只需证明$uv$本身为其最小后缀，我们可以把所有的后缀分为两类，一类是由$u$的后缀加上$v$串的来，这部分的相对大小不会改变。另一类是$v$串的后缀，因为$v$本身也是Lyndon串，我们只需证明$v &gt; uv$，因为$v &gt; u$，显然成立 唯一性 证明：设$pre(s, i)$表示串$s$中$s[1 \\dots i]$所代表的前缀若有两种方案，取第一次不同的位置，设$|s_i| &gt; |s’_i|$令$s_i = s’i s’{i + 1} \\dots s’{k} pre(s{k + 1}, l)$反证法。根据定义，$s_i &lt; pre(s’{k + 1}, l) \\leqslant s’{k + 1} \\leqslant s’_i &lt; s_i$矛盾 Duval算法(下面内容抄袭并补充自参考资料2) 该算法可以在$O(n)$的时间内求出串$s$的Lyndon分解 测试地址 引理2：若字符串$v$和字符$c$满足$vc$是某个Lyndon串的前缀，则对于字符$d&gt;c$有$vd$是Lyndon串 证明：和上面同样的思路，对于$d$之前的后缀相对大小不会改变，之后的后缀只会变大 该算法中我们仅需维护三个变量$i, j, k$ $s[1..i - 1] = s_1 s_2 \\dots s_g$是固定下来的分解，也就是$\\forall l \\in [1, g] s_l$是Lyndon串且$s_l &gt; s_{l + 1}$ $s[i .. k - 1] = t_1 t_2 \\dots t_h v(h &gt; 1)$ 是没有固定的分解，满足$t_1$是Lyndon串，且$t_1 = t_2 = \\dots = t_h$，$v$是$t_h$的(可为空的)真前缀，且有$s_g &gt; s[i .. k - 1]$ 当前读入的字符是$s[k]$，令$j = k - |t_1|$ 分三种情况讨论 当$s[k] = s[j]$时，周期$k - j$继续保持 当$s[k] &gt; s[j]$时，合并得到$t_1 &lt;- t_1 t_2 \\dots t_h v s[k]$是Lyndon串 当$s[k] &lt; s[j]$时，$t_1, t_2, \\dots, t_h$的分解被固定下来，算法从$v$的开头处重新开始 #include&lt;bits/stdc++.h&gt; using namespace std; const int MAXN = (1 &lt;&lt; 21) + 1; char s[MAXN]; int main() { scanf(&quot;%s&quot;, s + 1); int N = strlen(s + 1), j, k; for(int i = 1; i &lt;= N;) { j = i; k = i + 1; while(k &lt;= N &amp;&amp; s[j] &lt;= s[k]) { if(s[j] &lt; s[k]) j = i; else j++; k++; } while(i &lt;= j) { printf(&quot;%d &quot;, i + k - j - 1); i += k - j; } } return 0; } 参考资料Lyndon word 金策—字符串选讲","categories":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://blog.attack204.com/categories/算法竞赛/"},{"name":"学习笔记","slug":"算法竞赛/学习笔记","permalink":"https://blog.attack204.com/categories/算法竞赛/学习笔记/"}],"tags":[{"name":"Lyndon Word","slug":"Lyndon-Word","permalink":"https://blog.attack204.com/tags/Lyndon-Word/"},{"name":"字符串","slug":"字符串","permalink":"https://blog.attack204.com/tags/字符串/"}],"keywords":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://blog.attack204.com/categories/算法竞赛/"},{"name":"学习笔记","slug":"算法竞赛/学习笔记","permalink":"https://blog.attack204.com/categories/算法竞赛/学习笔记/"}]},{"title":"浅谈'小球'与'盒子'之间的奇葩关系","slug":"浅谈-小球-与-盒子-之间的奇葩关系","date":"2019-02-24T04:24:17.000Z","updated":"2019-02-26T01:30:21.995Z","comments":true,"path":"2019/02/24/浅谈-小球-与-盒子-之间的奇葩关系/","link":"","permalink":"https://blog.attack204.com/2019/02/24/浅谈-小球-与-盒子-之间的奇葩关系/","excerpt":"","text":"这玩意儿的官方名字应该是叫”Twelvefold way”，共用12种情况。 球异，盒同不空该情况为经典的第二类斯特灵数 设$f[n][m]$表示答案。 $f[n][m] = f[n - 1][m - 1] + m \\times f[n - 1][m]$ 边界条件：$f[0][0] = 1$ 答案 = 第$n$个数单独占一个盒子 + 第$n$个数和之前的数共占一个盒子，同时考虑不同位置的贡献 注意最后要乘$m$，因为第$n$个数放置的位置对答案是有影响的 例如{1}{2 4}{3}与{1}{2}{3 4}是不同的方案 题目中的应用 可空直接枚举用了多少个盒子 设$g[n][m]$表示答案 则$g[n][m] = \\sum_{i = 0}^m g[n][i]$ 至多放$1$此类”至多放$1$”的问题若$n&gt;m$则方案数一定为$0$ 答案为$[n &lt;= m]$ 球异，盒异可空每一个球都有$m$种放法，故答案为$m^n$ 不空设$g[n][m]$表示答案，$s[n][m]$为第二类斯特灵数 则$g[n][m] = s[n][m] \\times m!$ 相当于是考虑$m$个盒子的顺序 至多放$1$$ans = m!(m-1)! \\dots (m - n + 1) ! = \\frac{m!}{(m-n)!}$ 球同，盒异不空插板法的经典例题 $n$个球之间形成$n - 1$个空位，把$m$个盒子塞到里面 方案为$C_{n - 1}^{m - 1}$ 可空注意这里不能直接套用“插板法”得到$C_{n+1}^{m - 1}$ 因为使用插板法的前提条件之一就是“分成的方案不能为空” 考虑先在每个盒子中放一个小球，那么剩下的小球再往里放的时候就可以无视“非空的条件了” 故方案为$C_{n+m-1}^{m - 1}$ 这里再补充一下为什么不能直接套用插板法 比如$n = 2, m = 3$时，方案为$6$，而直接套用插板法得到的答案为$3$。 究其原因，是因为没有考虑到两个板同时占了一个空位的情况。 至多放$1$考虑每个球放在了哪里。 $ans = C_m^n$ 球同，盒同###可空 这种情况下，不同方案之间与具体用了哪个球以及放到了哪个盒子里都没有必然的联系 区分不同方案的方法是：把每个盒子的球的个数从小到大排序，比较最终的情况是否相同 例如：$1 \\ 7 \\ 1$与$1 \\ 1 \\ 7 \\ $实际是一种方案 对于$n = 8, m = 3$而言一共有$10$种不同的放法 0 0 8 0 1 7 0 2 6 0 3 5 1 1 6 1 2 5 1 3 4 2 3 4 3 3 3 从上面的分析我们也不难得出结论 $n$个相同的小球放到$m$个相同的盒子里，盒子可以为空的方案数 与一个整数$n$拆成$m$段非递减序列的方案数相同 设$f[n][m]$表示$n$个小球放到$m$个相同的盒子里，盒子可以为空的方案数 边界条件为$f[0][k] = 1, f[1][k] = 1, f[k][1] = 1$ 递推方程$f[n][m] =\\begin{cases}f[n - m][m] + f[n][m - 1] &amp;n &gt;= m\\f[n][m - 1] &amp;n &lt; m\\end{cases}$ 解释一下： 我们考虑这$m$个位置中是否有空盒子 显然：答案 = $m$个位置中至少有$1$个位置为空的方案 + $m$个位置中全不为空的方案 不空我们可以先在所有盒子里都放了一个，然后对剩下的球讨论 同样可以得到一个结论： $n$个相同的球，放到$m$个相同的盒子里，盒子不能为空的方案数 与把整数$n$拆成$m$段，每段不能为$0$的方案数相同 设$g[n][m]$表示$n$个小球放到$m$个相同的盒子里，盒子不能为空的方案数 则$g[n][m] = f[n - m][m]$， 题目链接 至多放$1$$ans = [n &lt;= m]$ 参考资料“n个球放到m个盒子”问题整理","categories":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://blog.attack204.com/categories/算法竞赛/"},{"name":"学习笔记","slug":"算法竞赛/学习笔记","permalink":"https://blog.attack204.com/categories/算法竞赛/学习笔记/"}],"tags":[{"name":"组合数学","slug":"组合数学","permalink":"https://blog.attack204.com/tags/组合数学/"}],"keywords":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://blog.attack204.com/categories/算法竞赛/"},{"name":"学习笔记","slug":"算法竞赛/学习笔记","permalink":"https://blog.attack204.com/categories/算法竞赛/学习笔记/"}]},{"title":"浅谈st表","slug":"浅谈st表","date":"2019-02-23T03:46:40.000Z","updated":"2019-02-26T01:30:21.997Z","comments":true,"path":"2019/02/23/浅谈st表/","link":"","permalink":"https://blog.attack204.com/2019/02/23/浅谈st表/","excerpt":"","text":"ST表ST表的功能很简单 它是解决RMQ问题(区间最值问题)的一种强有力的工具 它可以做到$O(nlogn)$预处理，$O(1)$查询最值 算法ST表是利用的是倍增的思想 拿最大值来说 我们用$Max[i][j]$表示，从$i$位置开始的$2^j$个数中的最大值，例如$Max[i][1]$表示的是$i$位置和$i+1$位置中两个数的最大值 那么转移的时候我们可以把当前区间拆成两个区间并分别取最大值（注意这里的编号是从$1$开始的） 查询的时候也比较简单 我们计算出$log_2{\\text{区间长度}}$ 然后对于左端点和右端点分别进行查询，这样可以保证一定可以覆盖查询的区间 刚开始学的时候我不太理解为什么从右端点开始查的时候左端点是$r-2^k+1$ 实际很简单，因为我们需要找到一个点$x$，使得$x+2^k-1=r$ 这样的话就可以得到$x=r-2^k+1$ 上面讲的可能比较抽象，建议大家画个图好好理解一下 代码有了上面的知识，代码就比较好理解了 #include&lt;cstdio&gt; #include&lt;cmath&gt; #include&lt;algorithm&gt; using namespace std; const int MAXN = 1e6 + 10; inline int read() { char c = getchar(); int x = 0, f = 1; while (c &lt; &#39;0&#39; || c &gt; &#39;9&#39;) {if (c == &#39;-&#39;)f = -1; c = getchar();} while (c &gt;= &#39;0&#39; &amp;&amp; c &lt;= &#39;9&#39;) {x = x * 10 + c - &#39;0&#39;; c = getchar();} return x * f; } int Max[MAXN][21]; int Query(int l, int r) { int k = log2(r - l + 1); return max(Max[l][k], Max[r - (1 &lt;&lt; k) + 1][k]); //把拆出来的区间分别取最值 } int main() { int N = read(), M = read(); for (int i = 1; i &lt;= N; i++) Max[i][0] = read(); for (int j = 1; j &lt;= 21; j++) for (int i = 1; i + (1 &lt;&lt; j) - 1 &lt;= N; i++) //注意这里要控制边界 Max[i][j] = max(Max[i][j - 1], Max[i + (1 &lt;&lt; (j - 1))][j - 1]); //如果看不懂边界的话建议好好看看图 for (int i = 1; i &lt;= M; i++) { int l = read(), r = read(); printf(&quot;%d\\n&quot;, Query(l, r)); } return 0; }","categories":[{"name":"oi","slug":"oi","permalink":"https://blog.attack204.com/categories/oi/"},{"name":"学习笔记","slug":"oi/学习笔记","permalink":"https://blog.attack204.com/categories/oi/学习笔记/"}],"tags":[{"name":"st表","slug":"st表","permalink":"https://blog.attack204.com/tags/st表/"}],"keywords":[{"name":"oi","slug":"oi","permalink":"https://blog.attack204.com/categories/oi/"},{"name":"学习笔记","slug":"oi/学习笔记","permalink":"https://blog.attack204.com/categories/oi/学习笔记/"}]},{"title":"浅谈莫比乌斯反演常见套路","slug":"浅谈莫比乌斯反演常见套路","date":"2019-02-22T11:15:21.000Z","updated":"2019-02-26T01:30:21.999Z","comments":true,"path":"2019/02/22/浅谈莫比乌斯反演常见套路/","link":"","permalink":"https://blog.attack204.com/2019/02/22/浅谈莫比乌斯反演常见套路/","excerpt":"","text":"整理一下，不然再过三天就又忘了。 莫比乌斯反演的套路emmm，因为我做过的题太少了，所以可能非常不全。 以下的式子都是用$\\sum_{d \\ | n} \\mu(d) = [n = 1]$推出来的，想看”正规”形式的可以参考这里 如果不做特殊说明的话，$\\frac{n}{k}$默认为下取整，保证$n &lt; m$ $\\sum_{i = 1}^n \\sum_{j = 1}^m gcd(i, j) = k$这类应该是最基础的问题 \\begin{aligned}&amp;\\sum_{i = 1}^n \\sum_{j = 1}^m gcd(i, j) = k \\&amp;\\sum_{i = 1}^{\\frac{n}{k}} \\sum_{j = 1}^{\\frac{m}{k}} [gcd(i, j)]\\&amp;\\sum_{i = 1}^{\\frac{n}{k}} \\sum_{j = 1}^{\\frac{m}{k}} \\sum_{d \\ | gcd(i, j)} \\mu(d)\\&amp;\\sum_{i = 1}^{\\frac{n}{k}} \\sum_{j = 1}^{\\frac{m}{k}} \\sum_{d \\ | i} \\sum_{d \\ | j}\\mu(d)\\&amp;\\sum_{d = 1}^n \\mu(d) \\sum_{i = 1}^{\\frac{n}{k}} \\sum_{d \\ | i} \\sum_{j = 1}^{\\frac{m}{k}}\\sum_{d \\ | j} 1\\&amp;\\sum_{d = 1}^n \\mu(d) \\frac{n}{kd} \\frac{m}{kd}\\\\end{aligned} 然后直接对后面的数论分块就行了 题目BZOJ1101: [POI2007]Zap $\\sum_{i = 1}^n \\sum_{j = 1}^m gcd(i, j)$按照套路，枚举$gcd$ \\begin{aligned}&amp;\\sum_{d = 1}^n \\sum_{i = 1}^n \\sum_{j = 1}^m gcd(i, j) = d \\&amp;\\text{后面的一坨直接按照第一种套路推，最终会得到}\\&amp;\\sum_{d = 1}^n \\sum_{k=1}^n \\mu(k) \\frac{n}{kd} \\frac{m}{kd}\\&amp;\\text{设$T = kd$}\\&amp;\\sum_{T = 1}^n \\frac{n}{T} \\frac{m}{T} \\sum_{d \\ | T} d \\mu(\\frac{T}{d})\\end{aligned} 设$g(T) = \\sum_{d \\ | T} d \\mu(\\frac{T}{d}) $ 不难发现这是个严格的狄利克雷卷积的形式，那么显然$g$也是个积性函数，我们可以直接线性筛预处理后面的部分，数论分块搞前面的。总的复杂度就是$O(n + T\\sqrt{n})$ 拓展这里题目最常见的拓展就是在$gcd(i, j)$外面再套一个函数，处理的策略都是一样的，化到最后得到的基本也都是积性函数，如果不是就暴力筛，是的话线性筛。至于怎么线性筛积性函数可以看这里。 题目BZOJ4407: 于神之怒加强版 BZOJ4804: 欧拉心算 $\\prod_{i = 1}^n \\prod_{j = 1}^m gcd(i, j)$设$g(T) = \\prod_{d \\ | T} d^{\\mu(\\frac{T}{d})}$ 到了这里就有必要好好说说了，按照常规的套路反演出的$g(T)$应该是个积性函数，然而这里并不是，但是暴力打表之后可以发现一些规律 当$T$为质数的幂时, 设$T = p^q$，那么$g(T) = p$，除此之外$g(T) = 1$ 那么直接枚举质数的幂次更新$g$，由于质数的密度大概是$\\frac{n}{\\ln n}$，而且每个质数的枚举上界为$\\log n$那么总复杂度为$O(\\frac{n}{ln n}) \\log n = O(n)$ 拓展这种形式同样有许多的拓展，最常见的也是在$gcd$的那里再套上个什么函数 比如，[SDOI2017]数字表格就是要求 $$\\sum_{i = 1}^n \\sum_{j = 1}^m f(gcd(i, j))$$ 其中$f(i)$表示第$i$个斐波那契数 这种题就按照套路推，推到最后一步，如果发现$g(T)$不能快速计算就直接暴力枚举因子，不然就xjb找规律。。 小结莫比乌斯反演的一大特点就是套路性强，但是很多题还是相当有难度的，比如把某个问题转成反演，反演转图论。像我这种菜鸡肯定是这辈子都做不出来的qwq 参考资料山东2017夏令营丁明朔讲课","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://blog.attack204.com/categories/学习笔记/"},{"name":"oi","slug":"学习笔记/oi","permalink":"https://blog.attack204.com/categories/学习笔记/oi/"}],"tags":[{"name":"莫比乌斯反演","slug":"莫比乌斯反演","permalink":"https://blog.attack204.com/tags/莫比乌斯反演/"},{"name":"数论","slug":"数论","permalink":"https://blog.attack204.com/tags/数论/"}],"keywords":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://blog.attack204.com/categories/学习笔记/"},{"name":"oi","slug":"学习笔记/oi","permalink":"https://blog.attack204.com/categories/学习笔记/oi/"}]},{"title":"浅谈贝叶斯公式","slug":"浅谈贝叶斯公式","date":"2019-01-19T07:21:07.000Z","updated":"2019-02-26T01:30:22.001Z","comments":true,"path":"2019/01/19/浅谈贝叶斯公式/","link":"","permalink":"https://blog.attack204.com/2019/01/19/浅谈贝叶斯公式/","excerpt":"感觉这玩意儿挺好玩的，顺便填一下以前留下的坑。 有些内容是抄袭的以前的文章，有些是自己瞎编的。 warning：博主并不知道什么叫深度学习/机器学习/AI，只是一个数学爱好者/oier","text":"感觉这玩意儿挺好玩的，顺便填一下以前留下的坑。 有些内容是抄袭的以前的文章，有些是自己瞎编的。 warning：博主并不知道什么叫深度学习/机器学习/AI，只是一个数学爱好者/oier 独立独立：对于事件$A$和$B$，如果$P(AB)$=$P(A)P(B)$，那么称$A$和$B$是独立的。 所谓独立，最直观的理解即两事件的结果不会相互影响。 条件概率如果$P(B)&gt;0$，那么$A$在$B$下的条件概率为$$P(A|B)=\\frac{P(AB)}{P(B)}$$ 特别的，如果$A$与$B$独立，那么$P(A | B) = P(A)$ 同时移项之后我们也会得到一个显然的公式：$P(AB) = P(A |B) P(B)$，那么同时$P(AB) = P(B | A) P(A)$ 关于条件概率一种不错的理解方式(引自这里) 条件概率$P(A | B) = \\frac{P(AB)}{P(B)}$就是紫色部分的面积占右边整个圆圈的比例 贝叶斯公式对于事件$A$和$B$，如果$P(A)&gt;0$且$P(B)&gt;0$，那么 $$P(A|B)=\\frac{P(B\\mid A)P(A)}{P(B)}$$ 这个公式的证明是显然的，我们直接把推导的第二个公式带入条件概率公式即可 观察一下这个公式，我们实际上有四个未知量(左$1$右$3$)，而在题目中往往会告诉我们$P(AB)$或$P(B | A)P(A)$，此时我们还需要求解$P(B)$ 但是$P(B)$的决定因素可能不止与一个事件有关(这里可能有些抽象，等下会有例子。) 这里我们会用到全概率公式 全概率公式如果样本空间可以被划分为两两互斥的若干部分$A_1,\\ldots,A_k$，那么$$P(B)=\\sum_{i=1}^{k}P(B\\mid A_i)P(A_i)$$ 举个例子，样本空间被划分成了$A$和$A’$，此时我们可以用全概率公式来计算$B$事件发生的概率 $P(B) = P(B | A) P(A) + P(B | A’) P(A’)$ 这个公式可以用来处理$P(B)$不好直接计算的情况 现在回过头来，我们把全概率公式回带到贝叶斯公式中，我们就得到了一种船新的表示形式 如果我们得到了样本空间的一个划分$A_1,\\ldots,A_k$，结合全概率公式，对于任意$1\\leq i\\leq k$有 $$P(A_i\\mid B) = \\frac{P(B\\mid A_i)P(A_i)}{\\sum_j P(B\\mid A_j)P(A_j)} $$ 下面来看两道水题 例题垃圾邮件识别(题目是我自己xjb起的) Descripiton一个用户所有邮件分为两类：$A_1$代表垃圾邮件， $A_2$代表非垃圾邮件 根据经验，$P(A_1) = 0.7$， $P(A_2) = 0.3$。 令$B$表示邮件包含“免费”这一关键词，由历史邮件得知， $P(B|A_1) = 0.9$， $P(B|A_2) = 0.01$（注意：它们之和并不一定等于$1$）。 问若收到一封新邮件，包含了“免费”这一关键字，那么它是垃圾邮件的概率是多少 Solution题目要求的实际是$P(A_1|B)$ 根据条件概率公式 $$P(A_1|B)=\\frac{P(A_1|B)}{P(B)}$$ 转换为贝叶斯公式 $$P(A_1|B)=\\frac{P(B|A_1)P(A_1)}{P(B)}$$ 将分式底下$P(B)$这一项用全概率公式展开 $$P(A_1|B)=\\frac{P(B|A_1)P(A_1)}{P(B|A_1)P(A_1)+P(B|A_2)P(A_2)}$$ 然后就可以算了 $$P(A_1|B)=\\frac{0.90.7}{0.90.7+0.01*0.3}$$ $$\\approx 0.995260663507109004739336492891 \\% $$ 好恐怖。。 次品识别问题(也是我自己xjb起的) Description例1设某工厂有甲、乙、丙三个车间，生产同一种产品,已知各车间的产量分别占全厂产量的$25 \\%, 35 \\%, 40 \\%$,而且各车间的次品率依次为$5 \\%,4 \\%,2 \\%$.现从待出厂的产品中检查出一个次品,试判断它是由甲车间生产的概率 Solution设$P(A_i)$表示是由第$i$个车间生产的概率，$P(B)$表示生产出次品的概率，直接带入公式算即可 $P(A_1 | B) = \\frac{P(B | A_1)}{P(B | A_1)P(A_1) + P(B | A_2)P(A_2) + P(B | A_3) P(A_3}$ $P(A_1 | B) = \\frac{0.25 0.05}{0.25 0.05 + 0.35 0.04 + 0.4 0.02} \\approx 0.36231$ 总结通过以上瞎扯不难看出，贝叶斯公式在一类”逆概率”问题中比较常用，按理说应该是非常常见的概率只是，但是我还真没找到几道正经的OI题qwq 而且本文章中没有出现“先验概率”“后验概率”“似然函数”等字眼，原因是因为博主太菜了根本不知道怎么去解释。。 这篇文章只是从最简单的理论层面列出了几个公式，有兴趣的大佬可以深入学习 参考资料《浅析信息学竞赛中概率论的基础与应用》——2013年胡渊明国家集训队论文 怎样用非数学语言讲解贝叶斯定理(Bayes’s theorem)?","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://blog.attack204.com/categories/学习笔记/"}],"tags":[{"name":"贝叶斯公式","slug":"贝叶斯公式","permalink":"https://blog.attack204.com/tags/贝叶斯公式/"},{"name":"概率","slug":"概率","permalink":"https://blog.attack204.com/tags/概率/"}],"keywords":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://blog.attack204.com/categories/学习笔记/"}]},{"title":"css学习笔记","slug":"CSS学习笔记","date":"2019-01-19T04:34:07.000Z","updated":"2019-04-13T13:52:23.850Z","comments":true,"path":"2019/01/19/CSS学习笔记/","link":"","permalink":"https://blog.attack204.com/2019/01/19/CSS学习笔记/","excerpt":"css好神奇啊qwqqq","text":"css好神奇啊qwqqq 简介CSS 指层叠样式表 (Cascading Style Sheets) 样式定义如何显示 HTML 元素 样式通常存储在样式表中 把样式添加到 HTML 4.0 中，是为了解决内容与表现分离的问题 外部样式表可以极大提高工作效率 外部样式表通常存储在 CSS 文件中 多个样式定义可层叠为一 基础知识基础语法CSS 规则由两个主要的部分构成：选择器，以及一条或多条声明。 selector {declaration1; declaration2; ... declarationN } 使用方法外部样式表&lt;head&gt; &lt;link rel = &quot;stylesheet&quot; type = &quot;text/css&quot; href = &quot;mystyle.css&quot; /&gt; &lt;/head&gt; 该文件中只能含有样式表 hr {color: sienna;} p {margin-left: 20px;} body {background-image: url(&quot;images/back40.gif&quot;);} 内部样式表直接在&lt;head&gt;标签内插入即可 &lt;head&gt; &lt;style type=&quot;text/css&quot;&gt; hr {color: sienna;} p {margin-left: 20px;} body {background-image: url(&quot;images/back40.gif&quot;);} &lt;/style&gt; &lt;/head&gt; 内联样式直接调用标签的style属性 &lt;p style=&quot;color: sienna; margin-left: 20px&quot;&gt; This is a paragraph &lt;/p&gt; 选择器分组对选择器分组后，同一组内的选择器会分享相同的声明 若一个选择器被凡在了多个组内，则会同时拥有每个组的样式，当样式冲突时，按规则选择样式 继承问题大部分情况下会直接继承父亲的样式，但是可能会有浏览器兼容问题 样式背景背景色可以使用background-color来设置背景色 p { background-color:blue; padding:20px; width: 400px; } 注意： background-color 不能继承 背景图像可以使用background-image:来设置背景图片 p { background-image:url(&quot;https://pic.cnblogs.com/avatar/1101696/20180214111459.png&quot;); background-repeat: none; padding:20px; width: 400px; height:800px; } 注意： 不能继承 背景重复使用background-repeat: repeat-x可以设置背景图片重复， repeat-x 和 repeat-y 分别导致图像只在水平或垂直方向上重复，no-repeat 则不允许图像在任何方向上平铺。 p { background-image:url(&quot;https://pic.cnblogs.com/avatar/1101696/20180214111459.png&quot;); background-repeat: repeat-x; padding:20px; width: 400px; height:800px; } 背景定位background-position可以来设置图像位置 可以选用center, top, bottom, left, right body { background-image: url(&quot;http://wx4.sinaimg.cn/large/005S5cb6ly1fzaxhur5nwj3050050jrw.jpg&quot;); background-repeat: no-repeat; background-position: center; } 也可以直接用百分数值来定位 下面的方式可以使元素放在水平方向 2/3、垂直方向 1/3 处 body { background-image:url(&#39;http://wx4.sinaimg.cn/large/005S5cb6ly1fzaxhur5nwj3050050jrw.jpg&#39;); background-repeat:no-repeat; background-position:66% 33%; } 还可以设置长度 body { background-image:url(&#39;http://wx4.sinaimg.cn/large/005S5cb6ly1fzaxhur5nwj3050050jrw.jpg&#39;); background-repeat:no-repeat; background-position:50px 100px; } 背景关联可以使用background-attachment来固定图片 body { background-image:url(/i/eg_bg_02.gif); background-repeat:no-repeat; background-attachment:fixed } 文本缩进文本可以使用text-indent: 5em来缩进文本 可以使用负值来实现”悬挂缩进效果”，但是可能会超出浏览器边界，可以通过设置外边框和内边距来消除影响 同样可以使用百分比值来缩进，百分数相对于缩进元素的父元素的宽度 p { text-indent: 5em; } 水平对齐可以使用text-align:来实现文本对齐 值 left、right 和 center 会导致元素中的文本分别左对齐、右对齐和居中。 p { text-align : center; } 字符隔可以使用word-spacing : 2em来设置单词之间的标准间隔 字母间隔可以使用letter-spacing: 2em来设置字母之间的间隔 字符转换可以使用text-transform来设置大小写 none uppercase lowercase capitalize 默认值 none 对文本不做任何改动，将使用源文档中的原有大小写。顾名思义，uppercase 和 lowercase 将文本转换为全大写和全小写字符。最后，capitalize 只对每个单词的首字母大写。 文本装饰文本的text-decoration属性可以实现对文本的装饰 不过好像主流浏览器都不支持blink了。。 none 去掉所有装饰 underline 增加下划线 overline 增加上划线？ line-through 增加横穿线 blink 使文本闪烁 处理空白符可以使用white-space 字体指定字体系列font-family可以自定义字体 h1 {font-family: Georgia;} 字体风格font-style 框模型定位选择器派生选择器派生选择器允许我们根据文档的上下文关系来确定某个标签的样式。 例如 h2 strong { color: blue; } &lt;strong&gt;233&lt;/strong&gt; &lt;h2&gt;123&lt;strong&gt;233&lt;/strong&gt;.&lt;/h2&gt; 这样设置的话只有h2标签内的strong标签才会变蓝色 id选择器id 选择器可以为标有特定id的HTML元素指定特定的样式。 id 选择器以 “#” 来定义。 id选择器常用来建立派生选择器,且可以定义多次 效果： &lt;style&gt; #attack p { color:blue } #attack span { font-size:23px; } #attack { color:pink; } &lt;/style&gt; &lt;body&gt; &lt;div id = &quot;attack&quot;&gt; 123 &lt;p&gt;123&lt;/p&gt; &lt;span&gt;456&lt;/span&gt; &lt;/div&gt; &lt;/body&gt; 注意： 老版本的ie浏览器可能会忽略该规则，只需加一条定义就可以了 div#sidebar { border: 1px dotted #000; padding: 10px; } 类选择器类选择器通常用y一个点’.’来表示，它对整个class属性为ClassName的标签进行渲染 class也可以构建派生选择器, 元素也可以基于它们的类而被选择(用于区分不同的标签) .ClassName {text-align: center} &lt;style&gt; .attack p { color:blue } div.attack { font-size:46px; } &lt;/style&gt; &lt;body&gt; &lt;div class = &quot;attack&quot;&gt; &lt;p&gt;123&lt;/p&gt; &lt;span&gt;456&lt;/span&gt; &lt;/div&gt; &lt;p class = &quot;attack&quot;&gt;123&lt;/p&gt; &lt;/body&gt; 注意： 类名的第一个字符不能使用数字！ 属性选择器可以为拥有指定属性的 HTML 元素设置样式，而不仅限于 class 和 id 属性。 下面的例子为带有 title 属性的所有元素设置样式： [title] { color:red; } 注意： 只有在规定了 !DOCTYPE 时，IE7 和 IE8 才支持属性选择器。在 IE6 及更低的版本中，不支持属性选择。 直接使用title选择器对p和a标签无效..(要你何用。) 细节问题 当值为若干个单词时记得加引号 CSS本身对大小写并不敏感，但是当与HTML一起使用时对class和id的大小写敏感 权重由大到小排列 内联样式（在 HTML 元素内部） 内部样式表（位于 &lt;head&gt; 标签内部） 外部样式表 浏览器缺省设置","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://blog.attack204.com/categories/学习笔记/"}],"tags":[{"name":"css","slug":"css","permalink":"https://blog.attack204.com/tags/css/"}],"keywords":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://blog.attack204.com/categories/学习笔记/"}]},{"title":"git使用小结","slug":"git使用小结","date":"2019-01-18T13:29:07.000Z","updated":"2019-02-26T01:30:21.965Z","comments":true,"path":"2019/01/18/git使用小结/","link":"","permalink":"https://blog.attack204.com/2019/01/18/git使用小结/","excerpt":"记录一下，忘的太快了qwq","text":"记录一下，忘的太快了qwq 首先需要弄好SSH，这一部分我早就弄好了，等以后需要重新弄的时候再更新吧 上传方法1、首先进入文件夹，初始化工作目录 git init 2、把文件都添加到暂存区中 git add . 3、执行预提交命令 git commit -m &#39;提交说明&#39; 4、关联到远程库 git remote add origin 你的远程库地址 远程仓库地址可以在这里获取 5、获取远程库与本地同步合并（如果远程库不为空必须做这一步，否则后面的提交会失败） git pull --rebase origin master 6、把本地库的内容推送到远程，使用 git push命令 实际上是把当前分支master推送到远程。执行此命令后会要求输入用户名、密码，验证通过后即开始上传。(如果配好ssh的话则不需要输入用户名密码) git push -u origin master 常见错误nothing to commit, working tree clean就是说没有什么可以更新的。。 fatal: remote origin already exists.说明重复输入了第四步 这时候只要输入git remote rm origin，再输入原命令就可以了 常用命令 参考资料如何用命令将本地项目上传到git Git使用教程","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://blog.attack204.com/categories/学习笔记/"}],"tags":[{"name":"git","slug":"git","permalink":"https://blog.attack204.com/tags/git/"}],"keywords":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://blog.attack204.com/categories/学习笔记/"}]},{"title":"html学习笔记","slug":"html学习笔记","date":"2019-01-18T10:42:07.000Z","updated":"2019-02-26T01:30:21.969Z","comments":true,"path":"2019/01/18/html学习笔记/","link":"","permalink":"https://blog.attack204.com/2019/01/18/html学习笔记/","excerpt":"html好神奇啊qwq 记录一下颓的时候学的东西。","text":"html好神奇啊qwq 记录一下颓的时候学的东西。 标签body存放网站的主体内容 p段落标签 &lt;p&gt;123 &lt;/p&gt; 123 hx标题文本 一般分为6级 &lt;h1&gt; &lt;/h1&gt; 123 em, strong都可以表示强调内容。一般用strong多一些 &lt;strong&gt; &lt;/strong&gt; 123 spanspan是没有语义的，它的作用是为了设置单独样式 qq标签是短文本应用标签 网页会自动给其加上&quot;&quot; &lt;q&gt; &lt;/q&gt; 123 blockquote长文本引用 &lt;blockquote&gt; &lt;/blockquote&gt; 明月出天山，苍茫云海间。长风几万里，吹度玉门关。汉下白登道，胡窥青海湾。由来征战地，不见有人还。 戍客望边色，思归多苦颜。高楼当此夜，叹息未应闲。 br分行标签 一般写为&lt;br/&gt;， html4.01后可写为&lt;br&gt; &lt;br&gt; &amp;nbsp 空格使用&amp;nbsp可以给文本添加空格 &amp;nbsp &amp;nbsp &amp;nbsp &amp;nbsp &amp;nbsp 123 &amp;nbsp hr添加水平横线 html4.01版本` ` xhtml1.0版本` ` &lt;hr&gt; address用于添加联系地址信息。默认为斜体 &lt;address&gt;联系地址信息&lt;/address&gt; 联系地址信息 codecode标签可以加入一行代码 &lt;code&gt;#include&lt;iostream&gt;&lt;/code&gt; #include prepre标签可以插入大段代码 &lt;pre&gt; #include&lt;iostream&gt; using namespace std; int main() { puts(&quot;GG&quot;); return 0; } &lt;/pre&gt; #include using namespace std; int main() { puts(\"GG\"); return 0; } ulul为新闻信息列表，一般与li标签搭配使用 ul标签默认没有先后顺序 &lt;ul&gt; &lt;li&gt; a &lt;/li&gt; &lt;li&gt; b &lt;/li&gt; &lt;li&gt; c &lt;/li&gt; &lt;/ul&gt; a b c olol标签与ul标签的区别在于ol标签有先后顺序 &lt;ol&gt; &lt;li&gt; a &lt;/li&gt; &lt;li&gt; b &lt;/li&gt; &lt;li&gt; c &lt;/li&gt; &lt;/ol&gt; a b c divdiv标签应该是应用最广泛的标签，它可以把一些独立的逻辑部分划分出来，此时div标签充当了一个容器 &lt;div&gt; 123 &lt;/div&gt; 123 tabletable可以展示表格内容 其中又分为五个元素: table, tbody, tr, th, td 1、&lt;table&gt;…&lt;/table&gt;：整个表格以&lt;table&gt;标记开始、&lt;/table&gt;标记结束。 2、&lt;tbody&gt;…&lt;/tbody&gt;：如果不加&lt;thead&gt;&lt;tbody&gt;&lt;tfooter&gt; , table表格加载完后才显示。加上这些表格结构， tbody包含行的内容下载完优先显示，不必等待表格结束后在显示，同时如果表格很长，用tbody分段，可以一部分一部分地显示。（通俗理解table 可以按结构一块块的显示，不在等整个表格加载完后显示。） 3、&lt;tr&gt;…&lt;/tr&gt;：表格的一行，所以有几对tr 表格就有几行。 4、&lt;td&gt;…&lt;/td&gt;：表格的一个单元格，一行中包含几对&lt;td&gt;...&lt;/td&gt;，说明一行中就有几列。 5、&lt;th&gt;…&lt;/th&gt;：表格的头部的一个单元格，表格表头。 6、表格中列的个数，取决于一行中数据单元格的个数 &lt;table&gt; &lt;tr&gt; &lt;th&gt; 1 &lt;/th&gt; &lt;th&gt; 2 &lt;/th&gt; &lt;th&gt; 3 &lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; 1 &lt;/td&gt; &lt;td&gt; 2 &lt;/td&gt; &lt;td&gt; 3 &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; 4 &lt;/td&gt; &lt;td&gt; 5 &lt;/td&gt; &lt;td&gt; 6 &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; 1 2 3 1 2 3 4 5 6 summary与captionsummary可以为表格提供摘要，摘要默认不显示 caption可以为表格添加标题 &lt;table summary = &quot;test&quot;&gt; &lt;caption&gt; My table &lt;/caption&gt; &lt;tr&gt; &lt;th&gt; 1 &lt;/th&gt; &lt;th&gt; 2 &lt;/th&gt; &lt;th&gt; 3 &lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; 1 &lt;/td&gt; &lt;td&gt; 2 &lt;/td&gt; &lt;td&gt; 3 &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; 4 &lt;/td&gt; &lt;td&gt; 5 &lt;/td&gt; &lt;td&gt; 6 &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; My table 1 2 3 1 2 3 4 5 6 aa标签可以实现超链接 加入target = &quot;_blank&quot;可以实现在新标签页内打开 在href使用mailto可以链接email地址 &lt;a href=&quot;http://www.baidu.com&quot; title=&quot;鼠标滑过显示的文本&quot;&gt;链接显示的文本&lt;/a&gt; &lt;a href=&quot;http://www.baidu.com&quot; title=&quot;鼠标滑过显示的文本&quot; target = &quot;_blank&quot;&gt;链接显示的文本&lt;/a&gt; &lt;a href=&quot;mailto:757394026@qq.com&quot; title=&quot;鼠标滑过显示的文本&quot;&gt;在当前页面打开&lt;/a&gt; 在新页面打开 链接显示的文本 链接邮件 imgimg标签可以插入图片 &lt;img src=&quot;http://wx4.sinaimg.cn/mw690/005S5cb6ly1fzavtzhjpnj313o0fadg4.jpg&quot; alt=&quot;下载失败时的替换文本&quot; title = &quot;提示文本&quot;&gt; form表单标签表单可以把浏览者输入的数据传送到服务器端，这样服务器端程序就可以处理表单传过来的数据。 &lt;form&gt; ：&lt;form&gt;标签是成对出现的，以&lt;form&gt;开始，以&lt;/form&gt;结束。 2.action ：浏览者输入的数据被传送到的地方,比如一个PHP页面(save.php)。 3.method ： 数据传送的方式（get/post）。 注意: 1、所有表单控件（文本框、文本域、按钮、单选框、复选框等）都必须放在 标签之间（否则用户输入的信息可提交不到服务器上哦！）。 2、method : post/get 的区别这一部分内容属于后端程序员考虑的问题。感兴趣的小伙伴可以查看本小节的 wiki，里面有详细介绍。 &lt;form method=&quot;传送方式&quot; action=&quot;服务器文件&quot;&gt; &lt;form method=&quot;post&quot; action=&quot;save.php&quot;&gt; &lt;label for=&quot;username&quot;&gt;用户名:&lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;username&quot; /&gt; &lt;label for=&quot;pass&quot;&gt;密码:&lt;/label&gt; &lt;input type=&quot;password&quot; name=&quot;pass&quot; /&gt; &lt;/form&gt; 用户名: 密码: label标签label标签不会向用户呈现任何特殊效果，它的作用是为鼠标用户改进了可用性。如果你在 label 标签内点击文本，就会触发此控件。就是说，当用户单击选中该label标签时，浏览器就会自动将焦点转到和标签相关的表单控件上（就自动选中和该label标签相关连的表单控件上）。 &lt;label for=&quot;控件id名称&quot;&gt; &lt;form&gt; 你对什么运动感兴趣？&lt;br&gt; &lt;label for=&quot;SlowRun&quot;&gt;慢跑&lt;/label&gt; &lt;input type=&quot;checkbox&quot; id=&quot;SlowRun&quot;/&gt; &lt;br&gt; &lt;label for=&quot;Climb&quot;&gt;登山&lt;/label&gt; &lt;input type=&quot;checkbox&quot; id=&quot;Climb&quot;/&gt; &lt;br&gt; &lt;label for=&quot;Basketball&quot;&gt;篮球&lt;/label&gt; &lt;br&gt; &lt;/form&gt; 你对什么运动感兴趣？ 慢跑 登山 篮球 input文本/密码输入框就是一个输入框， 1、type： 当type=”text”时，输入框为文本输入框; 当type=”password”时, 输入框为密码输入框。 2、name：为文本框命名，以备后台程序ASP 、PHP使用。 3、value：为文本输入框设置默认值。(一般起到提示作用) &lt;form&gt; &lt;input type=&quot;text/password&quot; name=&quot;名称&quot; value=&quot;文本&quot; /&gt; &lt;/form&gt; input提交按钮当用户需要提交表单信息到服务器时，需要用到提交按钮。 type：只有当type值设置为submit时，按钮才有提交作用 value：按钮上显示的文字 &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt; input重置按钮重置按钮可以使表单内容恢复到最初始的样子 &lt;form method = &quot;post&quot; action = &quot;save.php&quot;&gt; &lt;label for = &quot;myName&quot;&gt; 姓名：&lt;/label&gt; &lt;input type = &quot;text&quot; value = &quot;123&quot; name = &quot;myName&quot; /&gt; &lt;input type = &quot;reset&quot; value = &quot;重置&quot; name = resertBtn&quot;&gt; &lt;/form&gt; 姓名： &lt;input type = “reset” value = “重置” name = resertBtn”&gt; input单选框，复选框就是单选框和复选框，以name属性来区分每一组。 1、type: 当 type=”radio” 时，控件为单选框 当 type=”checkbox” 时，控件为复选框 2、value：提交数据到服务器的值（后台程序PHP使用） 3、name：为控件命名，以备后台程序 ASP、PHP 使用 4、checked：当设置 checked=”checked” 时，该选项被默认选中 &lt;input type=&quot;radio/checkbox&quot; value=&quot;值&quot; name=&quot;名称&quot; checked=&quot;checked&quot;/&gt; textarea 文本域可以让用户输入大段文字 1、&lt;textarea&gt;标签是成对出现的，以&lt;textarea&gt;开始，以&lt;/textarea&gt;结束。 2、cols ：多行输入域的列数。 3、rows ：多行输入域的行数。 4、在&lt;textarea&gt;&lt;/textarea&gt;标签之间可以输入默认值。 &lt;form method=&quot;post&quot; action=&quot;save.php&quot;&gt; &lt;label&gt;联系我们&lt;/label&gt; &lt;textarea cols=&quot;50&quot; rows=&quot;10&quot; &gt;在这里输入内容...&lt;/textarea&gt; &lt;/form&gt; 联系我们 在这里输入内容… select下拉列表框select标签可以实现一个下拉列表框 1、value 是服务器提交的值 2.、selected=”selected”： 设置selected=”selected”属性，则该选项就被默认选中。 3、在标签内设置multiple = &quot;multiple属性可以进行多选 &lt;form action=&quot;save.php&quot; method=&quot;post&quot; &gt; &lt;label&gt;爱好:&lt;/label&gt; &lt;!-- &lt;select multiple = &quot;multiple&quot;&gt; --&gt; &lt;select&gt; &lt;option value=&quot;看书&quot;&gt;看书&lt;/option&gt; &lt;option selected=&quot;selected&quot; value=&quot;旅游&quot;&gt;旅游&lt;/option&gt; &lt;option value=&quot;运动&quot;&gt;运动&lt;/option&gt; &lt;option value=&quot;购物&quot;&gt;购物&lt;/option&gt; &lt;/select&gt; &lt;/form&gt; 爱好: 看书 旅游 运动 购物 ### &lt;&gt;&lt;/&gt; &lt;&gt;&lt;/&gt; ### &lt;&gt;&lt;/&gt; &lt;&gt;&lt;/&gt; 标签的属性分为全局属性和部分属性 全局属性idid是规定元素的唯一id，每个元素的id必须是互不相同的","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://blog.attack204.com/categories/学习笔记/"}],"tags":[{"name":"html","slug":"html","permalink":"https://blog.attack204.com/tags/html/"}],"keywords":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://blog.attack204.com/categories/学习笔记/"}]},{"title":"Hexo-Theme-Sakura","slug":"Hexo-Theme-Sakura","date":"2018-12-12T14:16:01.000Z","updated":"2019-02-26T01:30:21.957Z","comments":true,"path":"2018/12/12/Hexo-Theme-Sakura/","link":"","permalink":"https://blog.attack204.com/2018/12/12/Hexo-Theme-Sakura/","excerpt":"","text":"最近又一次接触到了web端全景，是在720yun上，发现有好多用户上传的全景照片。再也按捺不住那颗好奇的心，去探究了下720云是怎么实现web端全景展示的。 分析加载的资源我们使用f12开发者工具，查看分析找到了krp-player这个关键的js文件，并在js文件首部找到了它的原名”krpano”（稍微提一下：可能你还听说有其他插件或方式实现web全景:比如three.js，但那些都不是很成熟，存在大大小小的bug，而krpano比较成熟也是大部分全景网站所使用的，所以是收费的。）。于是搜索到了它的官网，并进行下载它的安装包（下载速度太慢可以搜索其百度网盘资源去下载） 安装krpano下载好后，双击安装到目录（自定义）。安装好后如下图 使用krpano使用教程可以参考krpano360的。准备一张或多张全景图：注意：要求的全景图长宽比为2:1直接将全景拖到需要生成类型的bat上（我这里是MAKE VTOUR (VR-OPT) droplet，也是教程所推荐的）然后krpano就好自动处理图片，并生成html网页文件。生成的文件和图片在同一目录，如我的图片在桌面，生成的文件也在桌面。这样子直接打开html文件还不能浏览全景图片，需要在服务器环境下访问才行（其他服务器环境也行）这里我们用krpano自带的server工具。双击它：可以看到服务开启的目录在krpano的安装目录下，我们可以把生成的文件复制过来访问：（这里我在安装目录下新建了一个文件夹）再打开之前server工具给的那个地址，进入到目录下，点击tour.html即可预览全景预览如下：发现它的水印是不是多的恐怖2333333，需要购买才能去除。或者…… 最后其实可以退一步，就用一些全景平台就行了，比如720yun。这篇文章仅是为了探究下全景实现，到此为止了大致了解了，完。","categories":[{"name":"技术","slug":"技术","permalink":"https://blog.attack204.com/categories/技术/"}],"tags":[{"name":"web","slug":"web","permalink":"https://blog.attack204.com/tags/web/"},{"name":"悦读","slug":"悦读","permalink":"https://blog.attack204.com/tags/悦读/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://blog.attack204.com/categories/技术/"}]},{"title":"Berlekamp-Massey算法学习笔记","slug":"Berlekamp-Massey算法学习笔记","date":"2018-12-11T13:40:07.000Z","updated":"2019-02-26T01:30:21.955Z","comments":true,"path":"2018/12/11/Berlekamp-Massey算法学习笔记/","link":"","permalink":"https://blog.attack204.com/2018/12/11/Berlekamp-Massey算法学习笔记/","excerpt":"很久之前就听说过这个算法，当时六校联考的时候Day1T1是一道很有意思的递推，神仙zzx不会做于是就拿BM算法艹出了递推式Orzzzzzzzzzzx","text":"很久之前就听说过这个算法，当时六校联考的时候Day1T1是一道很有意思的递推，神仙zzx不会做于是就拿BM算法艹出了递推式Orzzzzzzzzzzx 推荐一篇讲的详细的不能再详细的博客 我就不详细说了，只记一下自己感觉比较难理解的地方 设$r(m)$表示序列的递推式且长度为$m$ $f(r, i)$表示$\\sum_{j = 1}^m r_j * a[i - j]$ $\\delta(r, i)$表示$a[i] - f(r, i)$ $fail_i$表示第$i$个递推式出错的位置 对于某一个位置$i$，如果我们求出的$\\delta(r, i) \\not = 0$，这时候我们需要构造一个递推式$r’(m’)$，满足$\\forall j \\in [m’ + 1, i - 1] f(r’, j) = 0$且$f(r, i) = \\delta(r, i)$ 这样我们令$r = r + r’$就得到新位置的递推式了 $r’$可以这么构造 设$mul = \\frac{\\delta(r, i)}{\\delta(r, fail_{cnt - 1})}$ 那么$r’ = {0, 0, 0 \\dots, 0, mul, -mul * R_{cnt - 1} }$ $0$的个数为$i - fail_{cnt - 1} - 1$ 至于为什么这么构造是对的，我思考了挺长时间，简单的证明一下 首先对于$\\forall j \\in [m’ + 1, i - 1]$, $\\delta(r’, j) = 0$ 仔细想了想，，发现自己并不会证。。如果哪位大佬会的话可以教教本蒟蒻 感性理解就是因为$r$在$[1, M]$处满足任意位置为$0$，然后右移一下还满足？。。 至于为什么$f(r’, i) = \\delta(r, i)$ 可以这么考虑，前$i - fail_{cnt - 1} - 1$个位置产生的贡献为$0$ $mul$产生的贡献为$mul * a_{fail_{cnt - 1}}$ $-mul R_{cnt - 1}$产生的贡献为$-mul (a[fail_{cnt - 1}] - \\delta(r, fail_{cnt - 1]})$ 合并同类项后可以得到$mul * \\delta(r, fail_{cnt - 1}) = \\delta(r, i)$ 代码如下 #include&lt;bits/stdc++.h&gt; using namespace std; const int MAXN = 2005; const double eps = 1e-8; int cnt, fail[MAXN]; double val[MAXN], delta[MAXN]; vector &lt;double&gt; ans[MAXN]; int main() { int N; scanf(&quot;%d&quot;, &amp;N); for (int i = 1; i &lt;= N; i++) scanf(&quot;%lf&quot;, &amp;val[i]); for (int i = 1; i &lt;= N; i++) { double tmp = val[i]; for (int j = 0; j &lt; ans[cnt].size(); j++) tmp -= ans[cnt][j] * val[i - j - 1]; delta[i] = tmp; if (fabs(tmp) &lt;= eps) continue; fail[cnt] = i; if (cnt == 0) { ans[++cnt].resize(i); continue; } double mul = delta[i] / delta[fail[cnt - 1]]; cnt++; ans[cnt].resize(i - fail[cnt - 2] - 1); ans[cnt].push_back(mul); for (int j = 0; j &lt; ans[cnt - 2].size(); j++) ans[cnt].push_back(ans[cnt - 2][j] * -mul); if (ans[cnt].size() &lt; ans[cnt - 1].size()) ans[cnt].resize(ans[cnt - 1].size()); for (int j = 0; j &lt; ans[cnt - 1].size(); j++) ans[cnt][j] += ans[cnt - 1][j]; } for (int i = 0; i &lt; ans[cnt].size(); i++) cout &lt;&lt; ans[cnt][i] &lt;&lt; &#39; &#39;; return 0; }","categories":[{"name":"oi","slug":"oi","permalink":"https://blog.attack204.com/categories/oi/"}],"tags":[{"name":"oi","slug":"oi","permalink":"https://blog.attack204.com/tags/oi/"},{"name":"Berlekamp-Massey算法","slug":"Berlekamp-Massey算法","permalink":"https://blog.attack204.com/tags/Berlekamp-Massey算法/"}],"keywords":[{"name":"oi","slug":"oi","permalink":"https://blog.attack204.com/categories/oi/"}]},{"title":"Yelee换用Gitalk评论系统","slug":"Yelee换用Gitalk评论系统","date":"2018-12-11T04:25:01.000Z","updated":"2019-02-26T01:30:21.964Z","comments":true,"path":"2018/12/11/Yelee换用Gitalk评论系统/","link":"","permalink":"https://blog.attack204.com/2018/12/11/Yelee换用Gitalk评论系统/","excerpt":"嗯。。又换了个评论系统","text":"嗯。。又换了个评论系统 步骤主要还是因为我比较懒，而且valine的后台是在太难弄了。所以还是换成了第三方的评论系统Gitalk 首先在这里注册一个Github OAuth application 在Yelee主题目录下的_config.yml中添加 gitalk: on: true clientID: &#39;your clientID&#39; clientSecret: &#39;your clientSecret&#39; repo: &#39;attack204.github.io&#39; # 仓库地址 owner: &#39;attack204&#39; # 拥有者 admin: [&#39;attack204&#39;] # admin 用户 在_partial/comments下创建gitalk.ejs 注意！下面的id选项中如果按照原式方法填的话会出现Error: Validation Failed的问题 一个比较好的解决思路是直接填写id: &#39;&lt;%= page.title %&gt;&#39; &lt;section id=&#39;comments&#39; style=&#39;margin: 2em; padding: 2em; background: rgba(255, 255, 255, 0.5)&#39;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://unpkg.com/gitalk/dist/gitalk.css&quot;&gt; &lt;script src=&quot;https://unpkg.com/gitalk@latest/dist/gitalk.min.js&quot;&gt;&lt;/script&gt; &lt;div id=&quot;gitalk-container&quot;&gt;&lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; var gitalk = new Gitalk({ clientID: &#39;&lt;%= theme.gitalk.clientID %&gt;&#39;, clientSecret: &#39;&lt;%= theme.gitalk.clientSecret %&gt;&#39;, repo: &#39;&lt;%= theme.gitalk.repo %&gt;&#39;, owner: &#39;&lt;%= theme.gitalk.owner %&gt;&#39;, admin: [&#39;&lt;%= theme.gitalk.owner %&gt;&#39;], id: window.location.pathname }) gitalk.render(&#39;gitalk-container&#39;) &lt;/script&gt; &lt;/section&gt; 修改 _partial/article.ejs &lt;% if (!index &amp;&amp; post.comments){ %&gt; &lt;% if (theme.duoshuo.on) { %&gt; &lt;%- partial(&#39;comments/duoshuo&#39;, { key: post.path, title: post.title, url: config.url+url_for(post.path), }) %&gt; &lt;% } else if (theme.youyan.on) { %&gt; &lt;%- partial(&#39;comments/youyan&#39;) %&gt; &lt;% } else if (theme.disqus.on) { %&gt; &lt;%- partial(&#39;comments/disqus&#39;, { shortname: theme.disqus.shortname }) %&gt; &lt;% } else if (config.disqus_shortname) { %&gt; &lt;%- partial(&#39;comments/disqus&#39;, { shortname: config.disqus_shortname }) %&gt; &lt;% } else if (theme.valine.on) { %&gt; &lt;%- partial(&#39;comments/valine&#39;, { key: post.slug, title: post.title, url: config.url+url_for(post.path) }) %&gt; + &lt;% } else if (theme.gitalk.on) { %&gt; + &lt;%- partial(&#39;comments/gitalk&#39;) %&gt; &lt;% } %&gt; &lt;% } %&gt; 参考资料更换博客评论系统","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://blog.attack204.com/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://blog.attack204.com/tags/Hexo/"}],"keywords":[{"name":"Hexo","slug":"Hexo","permalink":"https://blog.attack204.com/categories/Hexo/"}]},{"title":"sublime实现markdown浏览器预览","slug":"sublime实现markdown浏览器预览","date":"2018-10-03T00:31:18.000Z","updated":"2019-02-26T01:30:21.970Z","comments":true,"path":"2018/10/03/sublime实现markdown浏览器预览/","link":"","permalink":"https://blog.attack204.com/2018/10/03/sublime实现markdown浏览器预览/","excerpt":"利用sublime实现markdown浏览器预览","text":"利用sublime实现markdown浏览器预览 效果预览 实现首先下载插件OmniMarkupPreviewer 方法：ctrl + shift + P 安装完成后搜索’OmniMarkupPreviewer’双击即可 下载完成后新建.md文件 按’ctrl + Alt + O’即可在浏览器内预览 注意这里可能会出现两个问题 404打开浏览器后可能会出现404情况 更改方法如下 加入代码 { &quot;renderer_options-MarkdownRenderer&quot;: { &quot;extensions&quot;: [&quot;tables&quot;, &quot;fenced_code&quot;, &quot;codehilite&quot;] } } Mathjax数学公式不支持打开 把这里的’false’改为’true’，过一会儿重启sublime即可","categories":[],"tags":[{"name":"sublime","slug":"sublime","permalink":"https://blog.attack204.com/tags/sublime/"}],"keywords":[]},{"title":"sublime实现背景透明化","slug":"sublime实现背景透明化","date":"2018-10-03T00:01:18.000Z","updated":"2019-02-26T01:30:21.972Z","comments":true,"path":"2018/10/03/sublime实现背景透明化/","link":"","permalink":"https://blog.attack204.com/2018/10/03/sublime实现背景透明化/","excerpt":"sublime不能自定义背景图片好气啊qwq","text":"sublime不能自定义背景图片好气啊qwq 预览老司机们就不要吐槽背景图了 实现方法首先下载插件，直接打包下载zip即可 地址：https://github.com/vhanla/SublimeTextTrans 下载完成后解压到packages目录 然后就搞定了！ 可以按Shift + ctril + 1-6来实现不同的亮度控制 如果觉得不合适的话可以去 SublimeTextTrans.sublime-settings 这个文件里更改 值越小越透明","categories":[],"tags":[{"name":"sublime","slug":"sublime","permalink":"https://blog.attack204.com/tags/sublime/"}],"keywords":[]},{"title":"sublime实现一键代码格式化","slug":"sublime实现一键代码格式化","date":"2018-10-02T13:35:18.000Z","updated":"2019-02-26T01:30:21.971Z","comments":true,"path":"2018/10/02/sublime实现一键代码格式化/","link":"","permalink":"https://blog.attack204.com/2018/10/02/sublime实现一键代码格式化/","excerpt":"用Astyle实现sublime代码一键格式化","text":"用Astyle实现sublime代码一键格式化 效果预览 实现首先下载插件SublimeAstyleFormatter 方法：ctrl + shift + P后输入install Package。 等待一段时间后输入SublimeAstyleFormatter即可自动下载 使用方法按下ctrl + Alt + F是默认格式化整个文件 按下ctrl + K + F即可格式化选中区域 该插件中有许多不同的风格可以选择 我比较习惯google代码风格，可以这样设置 然后把第$28$行改为 &quot;style&quot;: &quot;google&quot;, 完成！","categories":[],"tags":[{"name":"sublime","slug":"sublime","permalink":"https://blog.attack204.com/tags/sublime/"}],"keywords":[]},{"title":"关于本博客的说明","slug":"关于本博客的说明","date":"2018-04-30T12:30:03.000Z","updated":"2019-02-26T01:30:21.976Z","comments":true,"path":"2018/04/30/关于本博客的说明/","link":"","permalink":"https://blog.attack204.com/2018/04/30/关于本博客的说明/","excerpt":"","text":"好久没有更新过这个博客了，因为本人实在太懒了QWQ。。 不过今天实在是看不下去了，友言4.30就倒闭了，所以换了一个新的评论系统——valine，不得不说，这个评论系统是真的好用 然后又优化了很多细节，比如右下角那个看板娘，不过我不知道怎么改样式啊QWQ…不管怎么改都是那一个小人，大小也没法改QWQ…. 至于博客内容的话，有空就更新吧，主要还是用博客园","categories":[],"tags":[],"keywords":[]},{"title":"博弈论进阶之Multi-SG","slug":"博弈论进阶之Multi-SG","date":"2018-02-25T08:53:07.000Z","updated":"2019-02-26T01:30:21.986Z","comments":true,"path":"2018/02/25/博弈论进阶之Multi-SG/","link":"","permalink":"https://blog.attack204.com/2018/02/25/博弈论进阶之Multi-SG/","excerpt":"Multi-Nim从最简单的Nim模型开始 它的定义是这样的 有$n$堆石子，两个人可以从任意一堆石子中拿任意多个石子(不能不拿)或把一堆数量不少于$2$石子分为两堆不为空的石子，没法拿的人失败。问谁会胜利","text":"Multi-Nim从最简单的Nim模型开始 它的定义是这样的 有$n$堆石子，两个人可以从任意一堆石子中拿任意多个石子(不能不拿)或把一堆数量不少于$2$石子分为两堆不为空的石子，没法拿的人失败。问谁会胜利 博弈分析这个问题的本质还是Nim游戏，可以利用SG定理来解释 通过观察不难不发现，操作一与普通的Nim游戏等价 操作二实际上是将一个游戏分解为两个游戏，根据SG定理，我们可以通过异或运算把两个游戏连接到一起，作为一个后继状态 煮个栗子 SG(3)的后继状态有${ (0),(1),(2),(1,2) }$他们的SG值分别为${ 0,1,2,3 }$，因此$SG(3)=mex{ 0,1,2,3 }=4$ 另外这种游戏还有一个非常神奇的性质 $$SG\\left( x\\right) =\\begin{cases}x-1\\left( x\\mod4=0\\right) \\ x\\left( x\\mod4=1 \\lor 2\\right) \\ x+1\\left( x\\mod4=3\\right) \\end{cases}$$ 然后把这个结论背过就好啦233 Multi-SG根据上面的游戏，我们定义Multi-SG游戏 Multi-SG 游戏规定，在符合拓扑原则的前提下，一个单一游戏的后继可以为多个单一游戏。 Multi-SG其他规则与SG游戏相同。 注意在这里要分清楚后继与多个单一游戏 对于一个状态来说，不同的划分方法会产生多个不同的后继，而在一个后继中可能含有多个独立的游戏 一个后继状态的SG值即为后继状态中独立游戏的异或和 该状态的SG值即为后继状态的SG值中未出现过的最小值 例题难度跨度好大啊QWQ。。 直接放题解吧 HDU 3032 POJ 2311 BZOJ 2940 BZOJ 1188 洛谷 3235","categories":[{"name":"oi","slug":"oi","permalink":"https://blog.attack204.com/categories/oi/"}],"tags":[{"name":"oi","slug":"oi","permalink":"https://blog.attack204.com/tags/oi/"},{"name":"博弈论","slug":"博弈论","permalink":"https://blog.attack204.com/tags/博弈论/"},{"name":"Multi-SG","slug":"Multi-SG","permalink":"https://blog.attack204.com/tags/Multi-SG/"}],"keywords":[{"name":"oi","slug":"oi","permalink":"https://blog.attack204.com/categories/oi/"}]},{"title":"博弈论入门之斐波那契博弈","slug":"博弈论入门之斐波那契博弈","date":"2018-02-25T02:03:11.000Z","updated":"2019-02-26T01:30:21.983Z","comments":true,"path":"2018/02/25/博弈论入门之斐波那契博弈/","link":"","permalink":"https://blog.attack204.com/2018/02/25/博弈论入门之斐波那契博弈/","excerpt":"斐波那契博弈斐波那契博弈是一种经典的博弈问题 有一堆石子，两个顶尖聪明的人玩游戏，先取者可以取走任意多个，但不能全取完，以后每人取的石子数不能超过上个人的两倍","text":"斐波那契博弈斐波那契博弈是一种经典的博弈问题 有一堆石子，两个顶尖聪明的人玩游戏，先取者可以取走任意多个，但不能全取完，以后每人取的石子数不能超过上个人的两倍 结论斐波那契博弈有一个非常重要的性质： 先手必败，当且仅当石子数为斐波那契数 是不是很神奇？？ 证明： 懒得看了，这里有 代码HDU 2516 #include&lt;cstdio&gt; #include&lt;map&gt; int fib[233],x; std::map&lt;int,bool&gt;mp; int main() { fib[1]=1;fib[2]=1; for(int i=3;i&lt;=50;i++) fib[i]=fib[i-1]+fib[i-2],mp[fib[i]]=1; while(scanf(&quot;%d&quot;,&amp;x)&amp;&amp;x!=0) puts(mp[x]==1?&quot;Second win&quot;:&quot;First win&quot;); return 0; }","categories":[{"name":"oi","slug":"oi","permalink":"https://blog.attack204.com/categories/oi/"}],"tags":[{"name":"oi","slug":"oi","permalink":"https://blog.attack204.com/tags/oi/"},{"name":"博弈论","slug":"博弈论","permalink":"https://blog.attack204.com/tags/博弈论/"},{"name":"斐波那契博弈","slug":"斐波那契博弈","permalink":"https://blog.attack204.com/tags/斐波那契博弈/"}],"keywords":[{"name":"oi","slug":"oi","permalink":"https://blog.attack204.com/categories/oi/"}]},{"title":"博弈论入门之威佐夫博弈","slug":"博弈论入门之威佐夫博弈","date":"2018-02-25T01:12:34.000Z","updated":"2019-02-26T01:30:21.979Z","comments":true,"path":"2018/02/25/博弈论入门之威佐夫博弈/","link":"","permalink":"https://blog.attack204.com/2018/02/25/博弈论入门之威佐夫博弈/","excerpt":"威佐夫博弈威佐夫博弈是一类经典的博弈问题 有两堆石子，两个顶尖聪明的人在玩游戏，每次每个人可以从任意一堆石子中取任意多的石子或者从两堆石子中取同样多的石子，不能取得人输，分析谁会获得胜利","text":"威佐夫博弈威佐夫博弈是一类经典的博弈问题 有两堆石子，两个顶尖聪明的人在玩游戏，每次每个人可以从任意一堆石子中取任意多的石子或者从两堆石子中取同样多的石子，不能取得人输，分析谁会获得胜利 博弈分析威佐夫博弈不同于Nim游戏与巴什博奕，它的特殊之处在于不能将两堆石子分开分析。 前辈们在对该博弈游戏做了大量的探索之后最终找到了一些非常有意思的性质 下面的内容不想看的可以跳过直接看结论，其实也没啥乱用233，这部分就是为了拓宽视野的 定义先手必输的局势为奇异局势，前几个奇异局势为$(0,0),(1,2),(3,5),(4,7),(6,10) \\dots$ 假设$(x,y)$为第$k$个奇异局势 性质： $x$为前$1 \\dots k$个奇异局势中没有出现过的最小正整数，$y=x+k$ 打表找规律 任何一个自热数都包含在一个且仅有一个奇异局势中 感觉网上证的都不靠谱，那只好本蒟蒻亲自下手喽 证明这个结论，我们只需要证明两点:(1)任意自然数都出现过(2)任意自然数仅出现一次 对于(1)：反证法，设$v$这个数没有出现过，那么$v$可以做一个新的奇异局势的$x$ 对于(2): 反证法 假设数$v$出现了两次，那么$v$一定不是所在奇异局势的$x$($x$必须之前未出现) 那么$v$只能同时是两个奇异局势的$y$，又因为任意一个奇异局势的差值不相同，因此$v$不可能出现两次 任何操作都会将奇异局势变为非奇异局势 若取走一堆中的石子，那么两对石子的差值会改变，必将成为非奇异局势 若同时取走，因为同一个差值只会对应一种奇异局势，必将成为非奇异局势 可以采取适当的方法将非奇异局势变为奇异局势 显然 结论人们通过对上述性质的探索，同时结合Betty定理，给出了威佐夫博弈的重要结论 假设两堆石子为$(x,y)$（其中$x&lt;y$） 那么先手必败，当且仅当 $(y-x)*\\frac{(\\sqrt{5}+1)}{2}=x$ 其中的$\\frac{(\\sqrt{5}+1)}{2}$实际就是$1.618$，黄金分割数！怎么样，博弈论是不是很神奇？ 证明的话， 首先你要会证明Betty定理，链接在上面，如果度娘的证明看不懂可以看这里 威佐夫博弈结论的话可以看这里 代码题目 #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;cmath&gt; #define int long long using namespace std; main() { int a,b; scanf(&quot;%lld%lld&quot;,&amp;a,&amp;b); if(a&gt;b) swap(a,b); int temp=abs(a-b); int ans=temp*(1.0+sqrt(5.0))/2.0; if(ans==a) printf(&quot;0&quot;); else printf(&quot;1&quot;); return 0; } 例题HDU 1527 题解 51NOD 1185 题解","categories":[{"name":"oi","slug":"oi","permalink":"https://blog.attack204.com/categories/oi/"}],"tags":[{"name":"oi","slug":"oi","permalink":"https://blog.attack204.com/tags/oi/"},{"name":"博弈论","slug":"博弈论","permalink":"https://blog.attack204.com/tags/博弈论/"},{"name":"威佐夫博弈","slug":"威佐夫博弈","permalink":"https://blog.attack204.com/tags/威佐夫博弈/"}],"keywords":[{"name":"oi","slug":"oi","permalink":"https://blog.attack204.com/categories/oi/"}]},{"title":"博弈论进阶之Anti-SG游戏与SJ定理","slug":"博弈论进阶之Anti-SG游戏与SJ定理","date":"2018-02-24T00:16:27.000Z","updated":"2019-02-26T01:30:21.985Z","comments":true,"path":"2018/02/24/博弈论进阶之Anti-SG游戏与SJ定理/","link":"","permalink":"https://blog.attack204.com/2018/02/24/博弈论进阶之Anti-SG游戏与SJ定理/","excerpt":"前言在上一节中，我们初步了解了一下SG函数与SG定理。 今天我们来分析一下SG游戏的变式——Anti-SG游戏以及它所对应的SG定理","text":"前言在上一节中，我们初步了解了一下SG函数与SG定理。 今天我们来分析一下SG游戏的变式——Anti-SG游戏以及它所对应的SG定理 首先从最基本的Anti-Nim游戏开始 Anti-Nim游戏是这样的 有两个顶尖聪明的人在玩游戏，游戏规则是这样的：有$n$堆石子，两个人可以从任意一堆石子中拿任意多个石子(不能不拿)，拿走最后一个石子的人失败。问谁会胜利 博弈分析Anti-Nim游戏与Nim游戏唯一的不同就是两人的胜利条件发生了改变，不过这并不影响我们对结论的推导 对于这个游戏，先手必胜有两种情况 当每堆石子都只有一个，且游戏的SG值为$0$ 至少一堆石子多于一个，且游戏的SG值不为$0$ 粗略的证明一下 游戏大概可以被分为$3$种情况 每堆只有一个石子 当异或值为$0$时，先手必胜 当异或值不为$0$时，先手必败 只有一堆石子数大于1，先手必胜 经过分析不难发现，先手可以对数量大于1的那堆石子下手脚，从而构造出后手必败的状态 存在至少两堆石子数大于1 当异或和为0时，先手必败 当异或和不为0时，先手必败 这一步的结论与Nim游戏非常相似，同时它们的证明也非常相似，大概就是从异或和为$0$的状态无论怎样都会变为异或和不为$0$的状态，反过来从异或和不为$0$的状态总有一步能到达异或和为$0$的状态 推广按照我们学习SG函数的思路，我们是否可以把Anti-Nim游戏推广开来呢？ 答案是肯定的 定义Anti-SG游戏 Anti-SG游戏规定：决策集合为空的游戏者赢 其余规则与SG游戏相同 同时我们定义SJ定理 对于Anti-SG游戏，如果我们规定当局面中所有单一游戏的SG值为0时，游戏结束，则先手必胜当且仅当 (1)游戏的SG函数不为0且游戏中某个单一游戏的SG函数值大于1 (2)游戏的SG函数为0且没有某个单一游戏的SG函数大于1 证明与SG函数类似， 不追求完美的可以从DAG上归纳 追求完美的可以用模仿棋证明出该游戏的等价性然后推出该游戏是可数集合然后通过计算推出在模$2$意义下线性空间的基可以为$nim(0),nim(1)$最后归纳证明一个后继是若干Anti-nim游戏的游戏等价于$mex(S)$ 例题按照whx老师的说法 Anti-SG不怎么重要，我至今为止就做到过一道题 那道题在这儿 题解","categories":[{"name":"oi","slug":"oi","permalink":"https://blog.attack204.com/categories/oi/"}],"tags":[{"name":"oi","slug":"oi","permalink":"https://blog.attack204.com/tags/oi/"},{"name":"博弈论","slug":"博弈论","permalink":"https://blog.attack204.com/tags/博弈论/"},{"name":"Anti-SG","slug":"Anti-SG","permalink":"https://blog.attack204.com/tags/Anti-SG/"},{"name":"SJ定理","slug":"SJ定理","permalink":"https://blog.attack204.com/tags/SJ定理/"}],"keywords":[{"name":"oi","slug":"oi","permalink":"https://blog.attack204.com/categories/oi/"}]},{"title":"博弈论进阶之SG函数","slug":"博弈论进阶之SG函数","date":"2018-02-23T06:32:47.000Z","updated":"2019-02-26T01:30:21.988Z","comments":true,"path":"2018/02/23/博弈论进阶之SG函数/","link":"","permalink":"https://blog.attack204.com/2018/02/23/博弈论进阶之SG函数/","excerpt":"SG函数个人理解：SG函数是人们在研究博弈论的道路上迈出的重要一步，它把许多杂乱无章的博弈游戏通过某种规则结合在了一起，使得一类普遍的博弈问题得到了解决。 从SG函数开始，我们不再是单纯的同过找规律等方法去解决博弈问题，而是需要学习一些博弈论中基本的定理，来找到他们的共同特点","text":"SG函数个人理解：SG函数是人们在研究博弈论的道路上迈出的重要一步，它把许多杂乱无章的博弈游戏通过某种规则结合在了一起，使得一类普遍的博弈问题得到了解决。 从SG函数开始，我们不再是单纯的同过找规律等方法去解决博弈问题，而是需要学习一些博弈论中基本的定理，来找到他们的共同特点 那么就先介绍几个最基本的定理(也可以叫常识)吧 基本定理ICG游戏1.游戏有两个人参与，二者轮流做出决策。且这两个人的决策都对自己最有利。 2.当有一人无法做出决策时游戏结束，无法做出决策的人输。无论二者如何做出决策，游戏可以在有限步内结束。 3.游戏中的同一个状态不可能多次抵达。且游戏不会有平局出现。任意一个游戏者在某一确定状态可以作出的决策集合只与当前的状态有关，而与游戏者无关。 满足上述条件的问题我们称之为ICG游戏，ICG游戏属于组合游戏 最典型的nim游戏，就是一种ICG游戏 必胜态与必败态定义P-position与N-position P-position：必败态(简记为P)，即Previous-position,你可以直观的认为处于这种状态的人一定会输 N-position：必胜态(简记为N)，即Next-position，你可以直观的理解为处于这种状态的人一定会赢 这仅仅是最直观的定义 更严谨的定义为： 无法移动的状态(即terminal-position)为P 可以移动到P的局面为N 所有移动都会进入N的局面为P DAG(有向无环图)中的博弈在正式研究$SG$函数之前，我们先来研究一下DAG中的博弈 给定一张有向无环图，在起始定点有一枚棋子，两个顶尖聪明的人交替移动这枚棋子，不能移动的人算输 不要小看这个游戏，事实上，所有ICG问题都可以抽象为这种游戏(即把初始局面看做顶点，把从一个状态可以到另一个状态之间连边) SG函数下面我们来正式研究一下SG(Sprague-Grundy)函数 首先定义mex运算，这是一种集合中的运算，它表示最小的不属于集合的非负整数 例如$mex{1,2,3}=0$，$mex{0,2}=1$，$mex{0,1,2,3}=4$，$mex{}=0$ 对于给定的有向无环图，定义每个点的SG函数为 $SG(x)=mex {\\ SG(y)\\ |\\ x \\ can\\ go\\ to\\ y }$ 然而单单一个这样的空洞的函数是解决不了问题的，我们需要分析一下它的性质 所有汇点的$SG$函数为$0$ 这个性质比较显然，因为汇点的所有后继状态都是空集 当$SG(x)=0$时,该节点为必败点 由$SG$函数的性质易知该节点的所有后继节点$SG$值均不为$0$ 满足必败态的定义 当$SG(x)\\neq 0 $,该节点为必胜点 由$SG$函数的定义可知该节点的后继节点中一定有一个节点$SG=0$ 满足必胜态的定义 这样我们通过最基本的$SG$值的定义，我们就可以判断出一个状态是必胜态还是必败态 这个问题实际上就是我们前面讲的巴什博奕 如果这个问题再复杂一点呢？ 当这个棋盘上有$n$个棋子的时候呢？ 其实它们的分析思路是一样的 当$SG(x)=k$时，它表明后继状态中含有$SG(y)=1 \\dots k-1$ 也就是说，我们从$k$可以转移到$1 \\dots k-1$中的任何一个状态，而当前共有$n$个棋子。 这会让你想到什么？ nim取石子游戏！ 那我们是不是也可以推出： 如果在nim游戏中的$n$堆石子的$SG$值异或和不为$0$就说明先手必胜呢？ 这是肯定的，因为当你打出nim游戏的$SG$值表时就会发现，$SG_{nim}(x)=x$ 是不是很神奇？ SG定理SG函数的应用远远不止和巴什博奕与nim游戏有关，我们回过头来考虑能否把SG函数推广开来 类比nim取石子游戏的思路，我们可不可以大胆设想： 游戏的和的SG值是他们的SG值的xor 暂且不管这个结论对不对，我们设想一下，假如这个结论对的话，会有什么后果. 我们可以将ICG问题对应到DAG上，然后直接通过SG函数之间的转移而解决几乎全部的问题 是不是很令人兴奋？ 更令人兴奋的是，这个定理是正确的！ 什么？证明？ 如果你是一个追求完美的人可以看这里 如果你像我一样连线性代数都不知道是什么的话大概就是从DAG上归纳一下就好了吧 SG定理的应用SG定理的应用非常的广泛，几乎所有的博弈类问题都有它的影子，本文仅仅是简单的介绍一下这个定理，更深层次的应用以后会补充的 上面提到了SG函数，那么SG函数的值是怎么计算的呢？ 很简单，我们直接通过$mex$运算的定义就可以计算了 int F[MAXN];//可以转移的状态集合，一般题目会给出 int S[MAXN];//表示该点可以转移到的状态有哪些 int SG[MAXN];//该点的SG值 void GetSG() { for(int i=1;i&lt;=N;i++)//枚举DAG中所有点 { memset(S,0,sizeof(S));//初始化 for(int j=1;j&lt;=limit&amp;&amp;F[j]&lt;=i;j++)//limit表示转移的集合的大小 S[SG[i-F[j]]]=1; for(int j=1;;j++) if(!S[j]) {SG[i]=i;break;}//根据定义计算SG函数 } } 来一道裸题 题解","categories":[{"name":"oi","slug":"oi","permalink":"https://blog.attack204.com/categories/oi/"}],"tags":[{"name":"oi","slug":"oi","permalink":"https://blog.attack204.com/tags/oi/"},{"name":"博弈论","slug":"博弈论","permalink":"https://blog.attack204.com/tags/博弈论/"},{"name":"SG函数","slug":"SG函数","permalink":"https://blog.attack204.com/tags/SG函数/"}],"keywords":[{"name":"oi","slug":"oi","permalink":"https://blog.attack204.com/categories/oi/"}]},{"title":"博弈论入门之nim游戏","slug":"博弈论入门之nim游戏","date":"2018-02-22T13:31:49.000Z","updated":"2019-02-26T01:30:21.978Z","comments":true,"path":"2018/02/22/博弈论入门之nim游戏/","link":"","permalink":"https://blog.attack204.com/2018/02/22/博弈论入门之nim游戏/","excerpt":"nim游戏 nim游戏 有两个顶尖聪明的人在玩游戏，游戏规则是这样的： 有$n$堆石子，两个人可以从任意一堆石子中拿任意多个石子(不能不拿)，没法拿的人失败。问谁会胜利","text":"nim游戏 nim游戏 有两个顶尖聪明的人在玩游戏，游戏规则是这样的： 有$n$堆石子，两个人可以从任意一堆石子中拿任意多个石子(不能不拿)，没法拿的人失败。问谁会胜利 nim游戏是巴什博奕的升级版(不懂巴什博奕的可以看这里) 它不再是简单的一个状态，因此分析起来也棘手许多 如果说巴什博奕仅仅博弈论的一个引子的话， nim游戏就差不多算是真正的入门了 博弈分析面对新的博弈问题，我们按照套路，从简单的情况入手 当只有一堆石子的时候，先手可以全部拿走。先手必胜 当有两堆石子且石子个数相同的时候，先手不论拿多少，后手都可以从另一堆中拿同样多的石子，先手必败，否则先手必胜 当有三堆的时候呢？ 当有$n$堆的时候呢？ 这样玩下去却是很繁琐，不过前辈们总结出了一条非常厉害的规律！ 定理解析定理对于nim游戏，前辈们发现了一条重要的规律！ 当$n$堆石子的数量异或和等于$0$时，先手必胜，否则先手必败 证明设$\\oplus$表示异或运算 nim游戏的必败态我们是知道的，就是当前$n$堆石子的数量都为零 设$a[i]$表示第$i$堆石子的数量，那么当前局面就是 $0 \\oplus 0 \\oplus 0 \\oplus \\dots \\oplus 0 = 0 $ 对于先手来说，如果当前局面是 $a_1 \\oplus a_2 \\oplus a_3 \\oplus \\dots \\oplus a_n = k$ 那么一定存在某个$a_i$，它的二进制表示在$k$最高位上一定是$1$ 我们将$a_i \\oplus k$，这样就变成了 $a_1 \\oplus a_2 \\oplus a_3 \\oplus \\dots \\oplus a_n \\oplus k = 0$ 此时先手必胜 对于先手来说，如果当前局面是 $a_1 \\oplus a_2 \\oplus a_3 \\oplus \\dots \\oplus a_n = k$ 那么我们不可能将某一个$a_i$异或一个数字后使得 $a_1 \\oplus a_2 \\oplus a_3 \\oplus \\dots \\oplus a_n = 0$ 此时先手必败 代码#include&lt;cstdio&gt; using namespace std; int a[10001]; int main() { int Test; scanf(&quot;%d&quot;,&amp;Test); while(Test--) { int ans=0,N; scanf(&quot;%d&quot;,&amp;N); for(int i=1;i&lt;=N;i++) scanf(&quot;%d&quot;,&amp;a[i]); for(int i=1;i&lt;=N;i++) ans=ans^a[i]; ans==0?printf(&quot;No\\n&quot;):printf(&quot;Yes\\n&quot;); } return 0; } 题目临时还没有做太多题目，以后做多了慢慢补吧 洛谷P2197 题解 POJ 1704 估计没几个人能一眼秒吧233 题解","categories":[{"name":"oi","slug":"oi","permalink":"https://blog.attack204.com/categories/oi/"}],"tags":[{"name":"oi","slug":"oi","permalink":"https://blog.attack204.com/tags/oi/"},{"name":"博弈论","slug":"博弈论","permalink":"https://blog.attack204.com/tags/博弈论/"},{"name":"nim游戏","slug":"nim游戏","permalink":"https://blog.attack204.com/tags/nim游戏/"}],"keywords":[{"name":"oi","slug":"oi","permalink":"https://blog.attack204.com/categories/oi/"}]},{"title":"博弈论入门之巴什博奕","slug":"博弈论入门之巴什博奕","date":"2018-02-22T12:21:50.000Z","updated":"2019-02-26T01:30:21.981Z","comments":true,"path":"2018/02/22/博弈论入门之巴什博奕/","link":"","permalink":"https://blog.attack204.com/2018/02/22/博弈论入门之巴什博奕/","excerpt":"巴什博奕 巴什博奕： 两个顶尖聪明的人在玩游戏，有$n$个石子，每人可以随便拿$1-m$个石子，不能拿的人为败者，问谁会胜利 巴什博奕是博弈论问题中基础的问题 它是最简单的一种情形对应一种状态的博弈","text":"巴什博奕 巴什博奕： 两个顶尖聪明的人在玩游戏，有$n$个石子，每人可以随便拿$1-m$个石子，不能拿的人为败者，问谁会胜利 巴什博奕是博弈论问题中基础的问题 它是最简单的一种情形对应一种状态的博弈 博弈分析我们从最简单的情景开始分析 当石子有$1-m$个时，毫无疑问，先手必胜 当石子有$m+1$个时，先手无论拿几个，后手都可以拿干净，先手必败 当石子有$m+2-2m$时，先手可以拿走几个，剩下$m+1$个，先手必胜 我们不难发现，面临$m+1$个石子的人一定失败。 这样的话两个人的最优策略一定是通过拿走石子，使得对方拿石子时还有$m+1$个 我们考虑往一般情况推广 设当前的石子数为$n=k*(m+1)+r$ 先手会首先拿走$r$个，接下来假设后手拿走$x$个，先手会拿走$m+1-k$个，这样博弈下去后手最终一定失败 设当前的石子数为$n=k*(m+1)$ 假设先手拿$x$个，后手一定会拿$m+1-x$个，这样下去先手一定失败 代码#include&lt;cstdio&gt; int main() { int n,m; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); if(n % (m+1) !=0) printf(&quot;first win&quot;); else printf(&quot;second win&quot;); return 0; } 题目 HDU1846 题解 HDU4764 题解 HDU1847 题解","categories":[{"name":"oi","slug":"oi","permalink":"https://blog.attack204.com/categories/oi/"}],"tags":[{"name":"oi","slug":"oi","permalink":"https://blog.attack204.com/tags/oi/"},{"name":"博弈论","slug":"博弈论","permalink":"https://blog.attack204.com/tags/博弈论/"},{"name":"巴什博奕","slug":"巴什博奕","permalink":"https://blog.attack204.com/tags/巴什博奕/"}],"keywords":[{"name":"oi","slug":"oi","permalink":"https://blog.attack204.com/categories/oi/"}]},{"title":"树链剖分","slug":"树链剖分","date":"2018-02-22T00:49:23.000Z","updated":"2019-03-22T08:09:24.379Z","comments":true,"path":"2018/02/22/树链剖分/","link":"","permalink":"https://blog.attack204.com/2018/02/22/树链剖分/","excerpt":"树链剖分是什么？ 树链剖分，说白了就是一种让你代码不得不强行增加1k的数据结构-dms 有什么用？ 证明出题人非常毒瘤 可以非常友(bao)好(li)的解决一些树上问题","text":"树链剖分是什么？ 树链剖分，说白了就是一种让你代码不得不强行增加1k的数据结构-dms 有什么用？ 证明出题人非常毒瘤 可以非常友(bao)好(li)的解决一些树上问题 核心思想树链剖分的思想比较神奇它的思想是：把一棵树拆成若干个不相交的链，然后用一些数据结构去维护这些链 那么问题来了.. 如何把树拆成链？ 首先明确一些定义 重儿子：该节点的子树中,节点个数最多的子树的根节点(也就是和该节点相连的点)，即为该节点的重儿子 重边：连接该节点与它的重儿子的边 重链：由一系列重边相连得到的链 轻链：由一系列非重边相连得到的链 这样就不难得到拆树的方法 对于每一个节点，找出它的重儿子，那么这棵树就自然而然的被拆成了许多重链与许多轻链 如何对这些链进行维护？ 首先，要对这些链进行维护，就要确保每个链上的节点都是连续的， 因此我们需要对整棵树进行重新编号，然后利用dfs序的思想，用线段树或树状数组等进行维护（具体用什么需要看题目要求，因为线段树的功能比树状数组强大，所以在这里我就不提供树状数组的写法了） 注意在进行重新编号的时候先访问重链 这样可以保证重链内的节点编号连续 上面说的太抽象了，结合一张图来理解一下 对于一棵最基本的树 给他标记重儿子， 蓝色为重儿子，红色为重边 然后对树进行重新编号 橙色表示的是该节点重新编号后的序号 不难看出重链内的节点编号是连续的 然后就可以在线段树上搞事情啦 像什么区间加区间求和什么的 另外有一个性质：以$i$为根的子树的树在线段树上的编号为$[i,i+子树节点数-1]$ 接下来结合一道例题，加深一下对于代码的理解 代码首先来一坨定义 int deep[MAXN];//节点的深度 int fa[MAXN];//节点的父亲 int son[MAXN];//节点的重儿子 int tot[MAXN];//节点子树的大小 第一步按照我们上面说的，我们首先要对整棵树dfs一遍，找出每个节点的重儿子 顺便处理出每个节点的深度，以及他们的父亲节点 int dfs1(int now,int f,int dep) { deep[now]=dep; fa[now]=f; tot[now]=1; int maxson=-1; for(int i=head[now];i!=-1;i=edge[i].nxt) { if(edge[i].v==f) continue; tot[now]+=dfs1(edge[i].v,now,dep+1); if(tot[edge[i].v]&gt;maxson) maxson=tot[edge[i].v],son[now]=edge[i].v; } return tot[now]; } 第二步然后我们需要对整棵树进行重新编号 我把一开始的每个节点的权值存在了$b$数组内 void dfs2(int now,int topf) { idx[now]=++cnt; a[cnt]=b[now]; top[now]=topf; if(!son[now]) return ; dfs2(son[now],topf); for(int i=head[now];i!=-1;i=edge[i].nxt) if(!idx[edge[i].v]) dfs2(edge[i].v,edge[i].v); } $idx$表示重新编号后该节点的编号是多少 另外，这里引入了一个$top$数组，$top[i]$表示$i$号节点所在重链的头节点(最顶上的节点)至于这个数组有啥用，后面再说 第三步我们需要根据重新编完号的树，把这棵树的上每个点映射到线段树上， struct Tree { int l,r,w,siz,f; }T[MAXN]; void Build(int k,int ll,int rr) { T[k].l=ll;T[k].r=rr;T[k].siz=rr-ll+1; if(ll==rr) { T[k].w=a[ll]; return ; } int mid=(ll+rr)&gt;&gt;1; Build(ls,ll,mid); Build(rs,mid+1,rr); update(k); } 另外线段树的基本操作，这里就不详细解释了 直接放代码 void update(int k)//更新 { T[k].w=(T[ls].w+T[rs].w+MOD)%MOD; } void IntervalAdd(int k,int ll,int rr,int val)//区间加 { if(ll&lt;=T[k].l&amp;&amp;T[k].r&lt;=rr) { T[k].w+=T[k].siz*val; T[k].f+=val; return ; } pushdown(k); int mid=(T[k].l+T[k].r)&gt;&gt;1; if(ll&lt;=mid) IntervalAdd(ls,ll,rr,val); if(rr&gt;mid) IntervalAdd(rs,ll,rr,val); update(k); } int IntervalSum(int k,int ll,int rr)//区间求和 { int ans=0; if(ll&lt;=T[k].l&amp;&amp;T[k].r&lt;=rr) return T[k].w; pushdown(k); int mid=(T[k].l+T[k].r)&gt;&gt;1; if(ll&lt;=mid) ans=(ans+IntervalSum(ls,ll,rr))%MOD; if(rr&gt;mid) ans=(ans+IntervalSum(rs,ll,rr))%MOD; return ans; } void pushdown(int k)//下传标记 { if(!T[k].f) return ; T[ls].w=(T[ls].w+T[ls].siz*T[k].f)%MOD; T[rs].w=(T[rs].w+T[rs].siz*T[k].f)%MOD; T[ls].f=(T[ls].f+T[k].f)%MOD; T[rs].f=(T[rs].f+T[k].f)%MOD; T[k].f=0; } 第四步我们考虑如何实现对于树上的操作 树链剖分的思想是:对于两个不在同一重链内的节点,让他们不断地跳,使得他们处于同一重链上 那么如何”跳”呢？ 还记得我们在第二次$dfs$中记录的$top$数组么？ 有一个显然的结论：$x$到$top[x]$中的节点在线段树上是连续的， 结合$deep$数组 假设两个节点为$x$,$y$ 我们每次让$deep[top[x]]$与$deep[top[y]]$中大的(在下面的)往上跳(有点类似于树上倍增) 让x节点直接跳到$top[x]$,然后在线段树上更新 最后两个节点一定是处于同一条重链的，前面我们提到过重链上的节点都是连续的，直接在线段树上进行一次查询就好 void TreeSum(int x,int y)//x与y路径上的和 { int ans=0; while(top[x]!=top[y]) { if(deep[top[x]]&lt;deep[top[y]]) swap(x,y); ans=(ans+IntervalSum(1,idx[ top[x] ],idx[x]))%MOD; x=fa[ top[x] ]; } if(deep[x]&gt;deep[y]) swap(x,y); ans=(ans+IntervalSum(1,idx[x],idx[y]))%MOD; printf(&quot;%d\\n&quot;,ans); } void TreeAdd(int x,int y,int val)//对于x,y路径上的点加val的权值 { while(top[x]!=top[y]) { if(deep[top[x]]&lt;deep[top[y]]) swap(x,y); IntervalAdd(1,idx[ top[x] ],idx[x],val); x=fa[ top[x] ]; } if(deep[x]&gt;deep[y]) swap(x,y); IntervalAdd(1,idx[x],idx[y],val); } 在树上查询的这一步可能有些抽象，我们结合一个例子来理解一下 还是上面那张图，假设我们要查询$3.6$这两个节点的之间的点权合，为了方便理解我们假设每个点的点权都是$1$ 刚开始时 $top[3]=2,top[6]=1$ $deep[top[3]]=2,deep[top[6]]=1$ 我们会让$3$向上跳,跳到$top[3]$的爸爸,也就是$1$号节点 这时$1$号节点和$6$号节点已经在同一条重链内,所以直接对线段树进行一次查询即可 对于子树的操作这个就更简单了 因为一棵树的子树在线段树上是连续的 所以修改的时候直接这样 IntervalAdd(1,idx[x],idx[x]+tot[x]-1,z%MOD); 时间复杂度性质1如果边$\\left( u,v\\right)$,为轻边,那么$Size\\left( v\\right) \\leq Size\\left( u\\right) /2$。 证明：显然，否则该边会成为重边 性质2树中任意两个节点之间的路径中轻边的条数不会超过$\\log _{2}n$,重路径的数目不会超过$\\log _{2}n$ 证明：不会 有了上面两条性质，我们就可以来分析时间复杂度了 由于重路径的数量的上界为$\\log _{2}n$， 线段树中查询/修改的复杂度为$\\log _{2}n$ 那么总的复杂度就是$\\left( \\log _{2}n\\right) ^{2}$ 完整代码#include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; using namespace std; const int MAXN=2*1e6+10; #define ls k&lt;&lt;1 #define rs k&lt;&lt;1|1 inline char nc() { static char buf[MAXN],*p1=buf,*p2=buf; return p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,MAXN,stdin),p1==p2)?EOF:*p1++; } inline int read() { char c=nc();int x=0,f=1; while(c&lt;&#39;0&#39;||c&gt;&#39;9&#39;){if(c==&#39;-&#39;)f=-1;c=nc();} while(c&gt;=&#39;0&#39;&amp;&amp;c&lt;=&#39;9&#39;){x=x*10+c-&#39;0&#39;,c=nc();} return x*f; } struct node { int u,v,nxt; }edge[MAXN]; int head[MAXN]; int num=1; struct Tree { int l,r,w,siz,f; }T[MAXN]; int N,M,root,MOD,cnt=0,a[MAXN],b[MAXN]; inline void AddEdge(int x,int y) { edge[num].u=x; edge[num].v=y; edge[num].nxt=head[x]; head[x]=num++; } int deep[MAXN],fa[MAXN],son[MAXN],tot[MAXN],top[MAXN],idx[MAXN]; int dfs1(int now,int f,int dep) { deep[now]=dep; fa[now]=f; tot[now]=1; int maxson=-1; for(int i=head[now];i!=-1;i=edge[i].nxt) { if(edge[i].v==f) continue; tot[now]+=dfs1(edge[i].v,now,dep+1); if(tot[edge[i].v]&gt;maxson) maxson=tot[edge[i].v],son[now]=edge[i].v; } return tot[now]; } void update(int k) { T[k].w=(T[ls].w+T[rs].w+MOD)%MOD; } void Build(int k,int ll,int rr) { T[k].l=ll;T[k].r=rr;T[k].siz=rr-ll+1; if(ll==rr) { T[k].w=a[ll]; return ; } int mid=(ll+rr)&gt;&gt;1; Build(ls,ll,mid); Build(rs,mid+1,rr); update(k); } void dfs2(int now,int topf) { idx[now]=++cnt; a[cnt]=b[now]; top[now]=topf; if(!son[now]) return ; dfs2(son[now],topf); for(int i=head[now];i!=-1;i=edge[i].nxt) if(!idx[edge[i].v]) dfs2(edge[i].v,edge[i].v); } void pushdown(int k) { if(!T[k].f) return ; T[ls].w=(T[ls].w+T[ls].siz*T[k].f)%MOD; T[rs].w=(T[rs].w+T[rs].siz*T[k].f)%MOD; T[ls].f=(T[ls].f+T[k].f)%MOD; T[rs].f=(T[rs].f+T[k].f)%MOD; T[k].f=0; } void IntervalAdd(int k,int ll,int rr,int val) { if(ll&lt;=T[k].l&amp;&amp;T[k].r&lt;=rr) { T[k].w+=T[k].siz*val; T[k].f+=val; return ; } pushdown(k); int mid=(T[k].l+T[k].r)&gt;&gt;1; if(ll&lt;=mid) IntervalAdd(ls,ll,rr,val); if(rr&gt;mid) IntervalAdd(rs,ll,rr,val); update(k); } void TreeAdd(int x,int y,int val) { while(top[x]!=top[y]) { if(deep[top[x]]&lt;deep[top[y]]) swap(x,y); IntervalAdd(1,idx[ top[x] ],idx[x],val); x=fa[ top[x] ]; } if(deep[x]&gt;deep[y]) swap(x,y); IntervalAdd(1,idx[x],idx[y],val); } int IntervalSum(int k,int ll,int rr) { int ans=0; if(ll&lt;=T[k].l&amp;&amp;T[k].r&lt;=rr) return T[k].w; pushdown(k); int mid=(T[k].l+T[k].r)&gt;&gt;1; if(ll&lt;=mid) ans=(ans+IntervalSum(ls,ll,rr))%MOD; if(rr&gt;mid) ans=(ans+IntervalSum(rs,ll,rr))%MOD; return ans; } void TreeSum(int x,int y) { int ans=0; while(top[x]!=top[y]) { if(deep[top[x]]&lt;deep[top[y]]) swap(x,y); ans=(ans+IntervalSum(1,idx[ top[x] ],idx[x]))%MOD; x=fa[ top[x] ]; } if(deep[x]&gt;deep[y]) swap(x,y); ans=(ans+IntervalSum(1,idx[x],idx[y]))%MOD; printf(&quot;%d\\n&quot;,ans); } int main() { #ifdef WIN32 freopen(&quot;a.in&quot;,&quot;r&quot;,stdin); #else #endif memset(head,-1,sizeof(head)); N=read();M=read();root=read();MOD=read(); for(int i=1;i&lt;=N;i++) b[i]=read(); for(int i=1;i&lt;=N-1;i++) { int x=read(),y=read(); AddEdge(x,y);AddEdge(y,x); } dfs1(root,0,1); dfs2(root,root); Build(1,1,N); while(M--) { int opt=read(),x,y,z; if(opt==1) { x=read();y=read();z=read();z=z%MOD; TreeAdd(x,y,z); } else if(opt==2) { x=read();y=read(); TreeSum(x,y); } else if(opt==3) { x=read(),z=read(); IntervalAdd(1,idx[x],idx[x]+tot[x]-1,z%MOD); } else if(opt==4) { x=read(); printf(&quot;%d\\n&quot;,IntervalSum(1,idx[x],idx[x]+tot[x]-1)); } } return 0; }","categories":[{"name":"oi","slug":"oi","permalink":"https://blog.attack204.com/categories/oi/"}],"tags":[{"name":"oi","slug":"oi","permalink":"https://blog.attack204.com/tags/oi/"},{"name":"树链剖分","slug":"树链剖分","permalink":"https://blog.attack204.com/tags/树链剖分/"}],"keywords":[{"name":"oi","slug":"oi","permalink":"https://blog.attack204.com/categories/oi/"}]},{"title":"次小生成树","slug":"次小生成树","date":"2018-02-21T13:55:45.000Z","updated":"2019-02-26T01:30:21.994Z","comments":true,"path":"2018/02/21/次小生成树/","link":"","permalink":"https://blog.attack204.com/2018/02/21/次小生成树/","excerpt":"我们已经熟知了求最小生成树的方法，用kruskal,prim算法都可以搞那么我们如何求次小生成树呢？这里次小生成树的定义是 边权和严格大于最小生成树的边权和最小的生成树","text":"我们已经熟知了求最小生成树的方法，用kruskal,prim算法都可以搞那么我们如何求次小生成树呢？这里次小生成树的定义是 边权和严格大于最小生成树的边权和最小的生成树 次小生成树次小生成树我们已经熟知了求最小生成树的方法，用kruskal,prim算法都可以搞那么我们如何求次小生成树呢？这里次小生成树的定义是 边权和严格大于最小生成树的边权和最小的生成树 求解方法次小生成树嘛，肯定和最小生成树脱不了关系那么我们首先求出最小生成树 接下来，一个比较显然的思路是枚举每一条未加入最小生成树的边，加入最小生成树，同时在最小生成树中删除边权最大的边如果你想到了这里并写出了代码，那么恭喜你你在里成功还有一步之遥成功掉进坑里了比如下面的例子蓝边表示最小生成树中的边，黄边表示新加入的边在这种情况下，如果仅仅记录最大值的话，得到的答案一定是错的所以我们还要记录严格小于最大值的最大值当产生冲突的时候我们需要删除严格小于最大值的最大值 优化但是这样效率太低了，每一次查询都是$O(n)$的有没有更好的方法呢？ 不要忘了，最小生成树它是一棵树呀树的链上最大最小值操作，你想到了什么？ 没错！树上倍增 我们在倍增的过程中记录下最大值和严格小于最大值的最大值 这样每次查询的复杂度就变成$log(n)$啦 总结流程整个算法的流程大概是 求出最小生成树 构造出倍增数组 每次树上倍增查询 时间复杂度用kruskal是$O(m\\log m+Q\\log (n))$用prim是$O(n\\log n+Q\\log (n))$Q为询问次数 代码放一道裸题 // luogu-judger-enable-o2 #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #include&lt;iostream&gt; #define int long long using namespace std; const int MAXN=400001; const int INF=1e15+10; inline int read() { char c=getchar();int x=0,f=1; while(c&lt;&#39;0&#39;||c&gt;&#39;9&#39;){if(c==&#39;-&#39;)f=-1;c=getchar();} while(c&gt;=&#39;0&#39;&amp;&amp;c&lt;=&#39;9&#39;){x=x*10+c-&#39;0&#39;;c=getchar();} return x*f; } struct Edge { int u,v,w; }E[MAXN]; int Enum=1; void Add(int x,int y,int z) { E[Enum].u=x; E[Enum].v=y; E[Enum].w=z;Enum++; } struct node { int u,v,w,nxt; }edge[MAXN]; int head[MAXN]; int num=1; int N,M; int fa[MAXN],vis[MAXN],sum; int deep[MAXN],f[MAXN][21],maxx[MAXN][21],minx[MAXN][21]; void AddEdge(int x,int y,int z) { edge[num].u=x; edge[num].v=y; edge[num].w=z; edge[num].nxt=head[x]; head[x]=num++; } int find(int x) { if(fa[x]==x) return fa[x]; else return fa[x]=find(fa[x]); } int unionn(int x,int y) { int fx=find(x),fy=find(y); fa[fx]=fy; } int comp(const Edge &amp;a,const Edge &amp;b) { return a.w&lt;b.w; } void Kruskal() { sort(E+1,E+Enum,comp); int tot=0; for(int i=1;i&lt;=Enum-1;i++) { int x=E[i].u,y=E[i].v; if(find(x)!=find(y)) { unionn(x,y),tot++,sum+=E[i].w,vis[i]=1; AddEdge(x,y,E[i].w);AddEdge(y,x,E[i].w); } if(tot==N-1) break; } } void dfs(int now,int fa) { for(int i=head[now];i!=-1;i=edge[i].nxt) { if(edge[i].v==fa) continue; deep[edge[i].v]=deep[edge[i].u]+1; f[edge[i].v][0]=now; maxx[edge[i].v][0]=edge[i].w; dfs(edge[i].v,now); } } void pre() { for(int i=1;i&lt;=18;i++) { for(int j=1;j&lt;=N;j++) { f[j][i]=f[ f[j][i-1] ][i-1]; maxx[j][i]=max(maxx[j][i-1],maxx[ f[j][i-1] ][i-1]); minx[j][i]=max(minx[j][i-1],minx[ f[j][i-1] ][i-1]); if(maxx[j][i-1]&gt;maxx[ f[j][i-1] ][i-1]) minx[j][i]=max(minx[j][i],maxx[ f[j][i-1] ][i-1]); else minx[j][i]=max(minx[j][i],maxx[j][i-1]); } } } int LCA(int x,int y) { if(deep[x]&lt;deep[y]) swap(x,y); for(int i=18;i&gt;=0;i--) if(deep[ f[x][i] ] &gt;= deep[y] ) x=f[x][i]; if(x==y) return x; for(int i=18;i&gt;=0;i--) if(f[x][i] != f[y][i]) x=f[x][i],y=f[y][i]; return f[x][0]; } int findmax(int x,int lca,int val) { int ans=0; for(int i=18;i&gt;=0;i--) { if(deep[ f[x][i] ] &gt;= deep[lca]) { if(maxx[x][i]==val) ans=max(ans,minx[x][i]); else ans=max(ans,maxx[x][i]); x=f[x][i]; } } return ans; } void work() { int ans=INF; for(int i=1;i&lt;=Enum-1;i++) { if(vis[i]) continue; int x=E[i].u,y=E[i].v,z=E[i].w; int lca=LCA(x,y); int lmx=findmax(x,lca,z); int rmx=findmax(y,lca,z); if(max(lmx,rmx)!=z) ans=min(ans,sum+z-max(lmx,rmx)); } printf(&quot;%lld&quot;,ans); } main() { #ifdef WIN32 freopen(&quot;a.in&quot;,&quot;r&quot;,stdin); #else #endif N=read(),M=read(); memset(head,-1,sizeof(head)); for(int i=1;i&lt;=N;i++) fa[i]=i; for(int i=1;i&lt;=M;i++) { int x=read(),y=read(),z=read(); Add(x,y,z); } Kruskal(); deep[1]=1; dfs(1,0); pre(); work(); return 0; }","categories":[{"name":"oi","slug":"oi","permalink":"https://blog.attack204.com/categories/oi/"}],"tags":[{"name":"oi","slug":"oi","permalink":"https://blog.attack204.com/tags/oi/"},{"name":"最小生成树","slug":"最小生成树","permalink":"https://blog.attack204.com/tags/最小生成树/"}],"keywords":[{"name":"oi","slug":"oi","permalink":"https://blog.attack204.com/categories/oi/"}]},{"title":"MatrixTree速成","slug":"MatrixTree速成","date":"2018-02-21T11:10:18.000Z","updated":"2019-02-26T01:30:21.962Z","comments":true,"path":"2018/02/21/MatrixTree速成/","link":"","permalink":"https://blog.attack204.com/2018/02/21/MatrixTree速成/","excerpt":"MatrixTree定理是用来解决生成树计数问题的有利工具 比如说这道题 MatrixTree定理的算法流程也非常简单 我们记矩阵$A$为无向图的度数矩阵 记矩阵$D$为无向图的邻接矩阵","text":"MatrixTree定理是用来解决生成树计数问题的有利工具 比如说这道题 MatrixTree定理的算法流程也非常简单 我们记矩阵$A$为无向图的度数矩阵 记矩阵$D$为无向图的邻接矩阵 前言MatrixTree定理是用来解决生成树计数问题的有利工具 比如说这道题 MatrixTree定理的算法流程也非常简单 我们记矩阵$A$为无向图的度数矩阵 记矩阵$D$为无向图的邻接矩阵 $A$矩阵是除了对角线之外各个点值都为$0$的矩阵，$A[i][i]$表示$i$号点的度数 $D$矩阵记录两点之间的度数，$D[i][j]$表示$i$号点与$j$号点之间的边数 MatrixTree定理我们记矩阵$G=A-D$那么$G$的所有不同生成树的个数等于$G$的任何一个 $n-1$ 阶主子式的行列式的绝对值 实现MatrixTree定理的实现非常简单 计算出$D$矩阵 后对其进行高斯消元 把消元后的矩阵的对角线乘起来 输出 代码就是上面那道题目的代码 #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; using namespace std; const int MAXN=3001; const double eps=1e-12; inline int read() { char c=getchar();int x=0,f=1; while(c&lt;&#39;0&#39;||c&gt;&#39;9&#39;){if(c==&#39;-&#39;)f=-1;c=getchar();} while(c&gt;=&#39;0&#39;&amp;&amp;c&lt;=&#39;9&#39;){x=x*10+c-&#39;0&#39;;c=getchar();} return x*f; } double G[MAXN][MAXN],a[MAXN][MAXN]; char s[MAXN][MAXN]; int xx[5]={0,-1,+1,0,0}; int yy[5]={0,0,0,-1,+1}; int N,M; int dcmp(int x) { if(x&lt;=eps||x&gt;=-eps) return 0; else return x&lt;0?-1:1; } void Gauss() { N--; for(int i=1;i&lt;=N;i++)//每一行 { int mx=i; for(int j=i+1;j&lt;=N;j++)//下面的每一行 if(dcmp(G[mx][i]-G[j][i])&lt;0) mx=j; if(mx!=i) swap(G[i],G[mx]); if(!G[i][i]) {printf(&quot;0\\n&quot;);return ;} for(int j=i+1;j&lt;=N;j++) { double t=G[j][i]/G[i][i]; for(int k=i;k&lt;=N+1;k++) G[j][k]-=t*G[i][k]; } } double ans=1; for(int i=1;i&lt;=N;i++) ans=ans*G[i][i]; printf(&quot;%.0f\\n&quot;,abs(ans)); } int main() { int T=read(); while(T--) { memset(G,0,sizeof(G)); N=read(),M=read(); for(int i=1;i&lt;=M;i++) { int x=read(),y=read(); G[x][x]++;G[y][y]++; G[x][y]--;G[y][x]--; } Gauss(); } return 0; }","categories":[],"tags":[{"name":"oi","slug":"oi","permalink":"https://blog.attack204.com/tags/oi/"},{"name":"线性代数","slug":"线性代数","permalink":"https://blog.attack204.com/tags/线性代数/"},{"name":"MatrixTree定理","slug":"MatrixTree定理","permalink":"https://blog.attack204.com/tags/MatrixTree定理/"}],"keywords":[]},{"title":"四边形不等式优化DP","slug":"四边形不等式优化DP","date":"2018-02-20T12:08:47.000Z","updated":"2019-02-26T01:30:21.989Z","comments":true,"path":"2018/02/20/四边形不等式优化DP/","link":"","permalink":"https://blog.attack204.com/2018/02/20/四边形不等式优化DP/","excerpt":"记录一下，以免忘了对于一个形如$$dp[i][j]=min(dp[i][k]+dp[k][j]+w[i][j])$$的转移方程（注意取最大值时不一定满足四边形不等式）","text":"记录一下，以免忘了对于一个形如$$dp[i][j]=min(dp[i][k]+dp[k][j]+w[i][j])$$的转移方程（注意取最大值时不一定满足四边形不等式） 记录一下，以免忘了 首先对于一个形如$$dp[i][j]=min(dp[i][k]+dp[k][j]+w[i][j])$$的转移方程（注意取最大值时不一定满足四边形不等式） 定理1若对于$a \\leq b\\leq c \\leq d$且$w_{b,c}\\leq w_{a,d}$那么我们称$w$关于区间包含关系单调 定理2若对于$a \\leq b\\leq c \\leq d$且$w_{a,c}+w_{b,d}\\leq w_{b,c}+w_{a,d}$则称$w$满足四边形不等式 性质1若$w$满足四边形不等式，当且仅当$w_{i,j}+w_{i+1,j+1}\\leq w_{i+1,j}+w_{i,j+1}$（没啥卵用） 性质2若$w$满足四边形不等式，且关于区间包含关系单调则$dp$也满足四边形不等式 性质3设$s_{i,j}$为$dp_{i,j}$的决策点，若$dp$满足四边形不等式那么$s_{i,j-1}\\leq s_{i,j} \\leq s_{i+1,j}$ 证明放一个不错的博客 例题石子归并加强版其实这题并不是极限数据，再强一点的可以去百度SDOI2008石子归并，据说要用平衡树维护某G姓算法 #include&lt;cstdio&gt; #include&lt;cstring&gt; const int MAXN=1e5+10,INF=1e8+10; using namespace std; inline char nc() { static char buf[MAXN],*p1=buf,*p2=buf; return p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,MAXN,stdin)),p1==p2?EOF:*p1++; } inline int read() { char c=nc();int x=0,f=1; while(c&lt;&#39;0&#39;||c&gt;&#39;9&#39;){if(c==&#39;-&#39;)f=-1;c=nc();} while(c&gt;=&#39;0&#39;&amp;&amp;c&lt;=&#39;9&#39;){x=x*10+c-&#39;0&#39;;c=nc();} return x*f; } int dp[3001][3001],sum[MAXN],s[3001][3001]; int main() { #ifdef WIN32 freopen(&quot;a.in&quot;,&quot;r&quot;,stdin); #else #endif int N=read(); for(int i=1;i&lt;=N;i++) sum[i]=read(),sum[i]+=sum[i-1],s[i][i]=i; for(int i=N;i&gt;=1;i--) { for(int j=i+1;j&lt;=N;j++) { int mn=INF,mnpos=0; for(int k=s[i][j-1];k&lt;=s[i+1][j];k++) { if(dp[i][k]+dp[k+1][j]+sum[j]-sum[i-1] &lt; mn) { mn=dp[i][k]+dp[k+1][j]+sum[j]-sum[i-1]; mnpos=k; } } dp[i][j]=mn; s[i][j]=mnpos; } } printf(&quot;%d&quot;,dp[1][N]); return 0; }","categories":[],"tags":[{"name":"DP优化","slug":"DP优化","permalink":"https://blog.attack204.com/tags/DP优化/"},{"name":"四边形不等式","slug":"四边形不等式","permalink":"https://blog.attack204.com/tags/四边形不等式/"}],"keywords":[]},{"title":"debug","slug":"test","date":"2018-02-20T10:56:45.000Z","updated":"2019-02-26T01:30:21.974Z","comments":true,"path":"2018/02/20/test/","link":"","permalink":"https://blog.attack204.com/2018/02/20/test/","excerpt":"测试文章 +","text":"测试文章 + # 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 一级标题二级标题三级标题四级标题&gt; 每段开头加&gt;可以引用 &gt;&gt; 加两个就是嵌套引用 &gt;&gt;&gt; 我真的还想再套八百年 每段开头加&gt;可以引用 加两个就是嵌套引用 我真的还想再套八百年 *我想变弯* **我想变胖** 集齐三颗星就能召唤分割线，三个-也可以 *** 我想变胖集齐三颗星就能召唤分割线，三个-也可以 要输入特殊符号就在前面加\\ 我不想\\*变弯\\*，只想露点\\*** 要输入特殊符号就在前面加\\我不想*变弯*，只想露点*** 每行开头空四格就能把文字变红并框起来，就像这样 或者用大键盘数字1左边的那个`符号引住也可以 每行开头空四格就能把文字变红并框起来，就像这样或者用大键盘数字1左边的那个`符号引住也可以 `妈妈`再也不用担心我输入不了`代码`啦 妈妈再也不用担心我输入不了代码啦 无序列表功能：人生三大错觉 - 手机响了 - 有人敲门 - Ta喜欢我 无序列表功能：人生三大错觉 手机响了 有人敲门 Ta喜欢我 有序列表功能：人生新三大错觉 1. 忙完这几天就能轻松了 2. 假期可以干很多有意义的事 3. 看完这个我就去睡觉 有序列表功能：人生新三大错觉 忙完这几天就能轻松了 假期可以干很多有意义的事 看完这个我就去睡觉","categories":[],"tags":[],"keywords":[]},{"title":"Hello World","slug":"hello-world","date":"2018-01-01T11:10:18.000Z","updated":"2019-02-26T01:30:21.967Z","comments":true,"path":"2018/01/01/hello-world/","link":"","permalink":"https://blog.attack204.com/2018/01/01/hello-world/","excerpt":"","text":"本版本仅适用于Win环境本文关键字： Hexo绿色版，Hexo便携版，Hexo配置，Hexo，U盘 Hexo是一个快速、简洁且高效的博客框架，支持 GitHub Flavored Markdown 的所有功能；具有超快生成速度，让上百个页面在几秒内瞬间完成渲染；还拥有各式各样的插件等等。 但是就像很多教程里面写的那样，搭建 Hexo 本地环境，需要安装 Node.js、Git 以及使用 npm 进行安装和配置。这对于毫无经验的新手来说，是一个很大的挑战。同时，由于这些环境的存在，导致如果需要更换计算机的时候，重新安装配置一个新的Hexo环境，又得花费一些功夫。 所以呢，锵锵，我们整合了一个 Hexo 便携版，来简化本地环境的部署。 ####版本介绍那么所谓的便携版到底是什么？便携版就是将 Hexo 本地环境所需要的各种依赖环境的整合到一起，做成的不需要安装的版本。 本便携版（Release 1.0.0）所包含的软件如下： Git: 2.7.4 Nodejs: 6.10.1 Npm: 4.4.1 Hexo: 3.2.2 为了便携的需要，不能配置固定的环境变量，所以除此之外还有相应的批处理文件，下文将详细介绍。 ####从零开始，1分钟搭建Hexo写作环境说了这么多，我们这就开始教你如何在1分钟内，从零开始搭建Hexo写作环境！ #####1 注册一个Github帐号 1.1 进入Github，并在右边的3个框框中分别填写 用户名、邮箱地址、账户密码，并点击 Sign up for Github; 1.2 进入欢迎页面后，点击Finish sign up; 1.3 进入到这一步之后（图1.3.1），先别记着点任何东西，查看你的邮箱，应该会收到如下的邮件（图1.3.2），确认你的邮件。否则，你会看到错误页面（图1.3.3）。query完毕之后在图1.3.1所示的页面，点击+ New repository; 1.4 请在红框中的 Repository name 里面输入 用户名.github.io ( 用户名 就是你刚刚 步骤1.1 中注册的用户名)，然后点击 Create repository; 1.5 至此，Github网页注册的部分完毕 ####2 下载HEXO Portable 2.1 访问我们的 HEXO Portable 页面，或者 Github仓库 下载最新的便携版； 2.2 双击得到的自解压文件，解压到你需要安装博客的地方，可以选择硬盘或者U盘； ####3 配置你的环境 3.1 在你的博客的文件夹，你会发现很多批处理文件，我先介绍下各个文件的用途： 配置基本信息 &gt;&gt; 配置博客的基本环境 配置Github部署 &gt;&gt; 配置博客的部署 启动命令行 &gt;&gt; 启动带环境变量的Git-Bash，否则无法使用node、npm、git等命令 新建文章 &gt;&gt; 新建一篇文章 渲染并本地测试 &gt;&gt; 生成并本地预览 渲染并部署 &gt;&gt; 生成并部署到GitHub 重置配置文件 &gt;&gt; 重置_config.yml 3.2 我们继续进行环境配置，双击配置基本信息并按顺序输入以下信息： 主标题：顾名思义 副标题：顾名思义 描述：顾名思义 作者：顾名思义 网站地址：填写 用户名.github.io （此处的用户名为步骤1.1中填写的用户名）如果您已经购买了域名，可以参看相关的文章！ 3.3 双击配置Github部署并按顺序输入以下信息： Github的用户名：此处的用户名为步骤1.1中填写的用户名 Github注册邮箱：此处的注册邮箱为步骤1.1中填写的注册邮箱 3.4 输入完毕之后，会进行测试部署，等待屏幕提示下面将进行部署测试，稍后将有一个openssh的对话框出现，请输入你的github用户密码。的时候，按回车继续；（此处的用户密码为步骤1.1中填写的用户密码） 3.5 然后继续等待，此时屏幕会出现n多行，耐心等待即可； 3.6 等待屏幕提示请访问 https://用户名.github.io 查看是否部署成功！的时候，在浏览器中输入https://用户名.github.io ，理论上可以看到你的Hexo站点！（此处的用户名为步骤1.1中填写的用户名） 3.7 至此，你的Hexo环境就配置完成了，这样你的这个Hexo博客文件夹无论移动到哪一台电脑，都能通过启动命令行出现的bash命令行，或者其余便捷的批处理文件比如新建文章、渲染并本地测试、渲染并部署进行相应的操作。 3.8 如果你在配置中出错，可以运行重置配置文件后，再重复3.1~3.6步骤 ####4 开始享受纯粹的Hexo写作吧！ ####5 备注 本便携版以及本文均使用 CC BY-NC-SA 4.0协议； 本文所有权归 QistChan &amp; Bitmoe Inc. 所有； 本便携版由 Bitmoe Inc. 维护并提供技术支持； 需要技术支持可以在Github仓库 提交Issues； Written with StackEdit.","categories":[],"tags":[],"keywords":[]}]}