{"meta":{"title":"Attack博客","subtitle":"一只oi界的小混混","description":"垃圾","author":"attack","url":"http://attack204.com"},"pages":[{"title":"about","date":"2018-02-20T12:46:29.000Z","updated":"2018-02-25T06:03:44.766Z","comments":true,"path":"about/index.html","permalink":"http://attack204.com/about/index.html","excerpt":"","text":"这是一个来自SD的大蒟蒻的blog这个博客会更新一些算法类的东西，题解类的东西在这里以前也考虑过用emlog，WordPress，typecho这些东西搭建博客，但我毕竟还是学生，只能用免费域名+免费空间。免费空间又经常炸，so我也不想操心去维护，就干脆用hexo+gitpage喽再就是这个blog鬼畜的评论系统，只有每天7点之前才能评论，也是醉了QwQ"},{"title":"categories","date":"2019-02-01T12:02:51.910Z","updated":"2017-08-16T07:34:26.000Z","comments":true,"path":"categories/index.html","permalink":"http://attack204.com/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2019-02-01T12:02:51.912Z","updated":"2017-08-16T07:34:26.000Z","comments":true,"path":"tags/index.html","permalink":"http://attack204.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"浅谈贝叶斯公式","slug":"浅谈贝叶斯公式","date":"2019-01-19T07:21:07.000Z","updated":"2019-01-20T03:41:24.688Z","comments":true,"path":"2019/01/19/浅谈贝叶斯公式/","link":"","permalink":"http://attack204.com/2019/01/19/浅谈贝叶斯公式/","excerpt":"感觉这玩意儿挺好玩的，顺便填一下以前留下的坑。有些内容是抄袭的以前的文章，有些是自己瞎编的。warning：博主并不知道什么叫深度学习/机器学习/AI，只是一个数学爱好者/oier","text":"感觉这玩意儿挺好玩的，顺便填一下以前留下的坑。有些内容是抄袭的以前的文章，有些是自己瞎编的。warning：博主并不知道什么叫深度学习/机器学习/AI，只是一个数学爱好者/oier独立独立：对于事件$A$和$B$，如果$P(AB)$=$P(A)P(B)$，那么称$A$和$B$是独立的。所谓独立，最直观的理解即两事件的结果不会相互影响。条件概率如果$P(B)&gt;0$，那么$A$在$B$下的条件概率为$$P(A|B)=\\frac{P(AB)}{P(B)}$$特别的，如果$A$与$B$独立，那么$P(A | B) = P(A)$同时移项之后我们也会得到一个显然的公式：$P(AB) = P(A |B) P(B)$，那么同时$P(AB) = P(B | A) P(A)$关于条件概率一种不错的理解方式(引自这里)条件概率$P(A | B) = \\frac{P(AB)}{P(B)}$就是紫色部分的面积占右边整个圆圈的比例贝叶斯公式对于事件$A$和$B$，如果$P(A)&gt;0$且$P(B)&gt;0$，那么$$P(A|B)=\\frac{P(B\\mid A)P(A)}{P(B)}$$这个公式的证明是显然的，我们直接把推导的第二个公式带入条件概率公式即可观察一下这个公式，我们实际上有四个未知量(左$1$右$3$)，而在题目中往往会告诉我们$P(AB)$或$P(B | A)P(A)$，此时我们还需要求解$P(B)$但是$P(B)$的决定因素可能不止与一个事件有关(这里可能有些抽象，等下会有例子。)这里我们会用到全概率公式全概率公式如果样本空间可以被划分为两两互斥的若干部分$A_1,\\ldots,A_k$，那么$$P(B)=\\sum_{i=1}^{k}P(B\\mid A_i)P(A_i)$$举个例子，样本空间被划分成了$A$和$A’$，此时我们可以用全概率公式来计算$B$事件发生的概率$P(B) = P(B | A) P(A) + P(B | A’) P(A’)$这个公式可以用来处理$P(B)$不好直接计算的情况现在回过头来，我们把全概率公式回带到贝叶斯公式中，我们就得到了一种船新的表示形式如果我们得到了样本空间的一个划分$A_1,\\ldots,A_k$，结合全概率公式，对于任意$1\\leq i\\leq k$有$$P(A_i\\mid B) = \\frac{P(B\\mid A_i)P(A_i)}{\\sum_j P(B\\mid A_j)P(A_j)} $$下面来看两道水题例题垃圾邮件识别(题目是我自己xjb起的)Descripiton一个用户所有邮件分为两类：$A_1$代表垃圾邮件， $A_2$代表非垃圾邮件根据经验，$P(A_1) = 0.7$， $P(A_2) = 0.3$。令$B$表示邮件包含“免费”这一关键词，由历史邮件得知， $P(B|A_1) = 0.9$，$P(B|A_2) = 0.01$（注意：它们之和并不一定等于$1$）。问若收到一封新邮件，包含了“免费”这一关键字，那么它是垃圾邮件的概率是多少Solution题目要求的实际是$P(A_1|B)$根据条件概率公式$$P(A_1|B)=\\frac{P(A_1|B)}{P(B)}$$转换为贝叶斯公式$$P(A_1|B)=\\frac{P(B|A_1)P(A_1)}{P(B)}$$将分式底下$P(B)$这一项用全概率公式展开$$P(A_1|B)=\\frac{P(B|A_1)P(A_1)}{P(B|A_1)P(A_1)+P(B|A_2)P(A_2)}$$然后就可以算了$$P(A_1|B)=\\frac{0.90.7}{0.90.7+0.01*0.3}$$$$\\approx 0.995260663507109004739336492891 \\% $$好恐怖。。次品识别问题(也是我自己xjb起的)Description例1设某工厂有甲、乙、丙三个车间，生产同一种产品,已知各车间的产量分别占全厂产量的$25 \\%, 35 \\%, 40 \\%$,而且各车间的次品率依次为$5 \\%,4 \\%,2 \\%$.现从待出厂的产品中检查出一个次品,试判断它是由甲车间生产的概率Solution设$P(A_i)$表示是由第$i$个车间生产的概率，$P(B)$表示生产出次品的概率，直接带入公式算即可$P(A_1 | B) = \\frac{P(B | A_1)}{P(B | A_1)P(A_1) + P(B | A_2)P(A_2) + P(B | A_3) P(A_3}$$P(A_1 | B) = \\frac{0.25 0.05}{0.25 0.05 + 0.35 0.04 + 0.4 0.02} \\approx 0.36231$总结通过以上瞎扯不难看出，贝叶斯公式在一类”逆概率”问题中比较常用，按理说应该是非常常见的概率只是，但是我还真没找到几道正经的OI题qwq而且本文章中没有出现“先验概率”“后验概率”“似然函数”等字眼，原因是因为博主太菜了根本不知道怎么去解释。。这篇文章只是从最简单的理论层面列出了几个公式，有兴趣的大佬可以深入学习参考资料《浅析信息学竞赛中概率论的基础与应用》——2013年胡渊明国家集训队论文怎样用非数学语言讲解贝叶斯定理(Bayes’s theorem)?","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://attack204.com/categories/学习笔记/"}],"tags":[{"name":"贝叶斯公式","slug":"贝叶斯公式","permalink":"http://attack204.com/tags/贝叶斯公式/"},{"name":"概率","slug":"概率","permalink":"http://attack204.com/tags/概率/"}]},{"title":"css学习笔记","slug":"CSS学习笔记","date":"2019-01-19T04:34:07.000Z","updated":"2019-01-20T04:59:20.869Z","comments":true,"path":"2019/01/19/CSS学习笔记/","link":"","permalink":"http://attack204.com/2019/01/19/CSS学习笔记/","excerpt":"css好神奇啊qwq","text":"css好神奇啊qwq简介CSS 指层叠样式表 (Cascading Style Sheets)样式定义如何显示 HTML 元素样式通常存储在样式表中把样式添加到 HTML 4.0 中，是为了解决内容与表现分离的问题外部样式表可以极大提高工作效率外部样式表通常存储在 CSS 文件中多个样式定义可层叠为一基础知识基础语法CSS 规则由两个主要的部分构成：选择器，以及一条或多条声明。1selector &#123;declaration1; declaration2; ... declarationN &#125;使用方法外部样式表123&lt;head&gt; &lt;link rel = \"stylesheet\" type = \"text/css\" href = \"mystyle.css\" /&gt;&lt;/head&gt;该文件中只能含有样式表123hr &#123;color: sienna;&#125;p &#123;margin-left: 20px;&#125;body &#123;background-image: url(\"images/back40.gif\");&#125;内部样式表直接在&lt;head&gt;标签内插入即可1234567&lt;head&gt;&lt;style type=\"text/css\"&gt; hr &#123;color: sienna;&#125; p &#123;margin-left: 20px;&#125; body &#123;background-image: url(\"images/back40.gif\");&#125;&lt;/style&gt;&lt;/head&gt;内联样式直接调用标签的style属性123&lt;p style=\"color: sienna; margin-left: 20px\"&gt; This is a paragraph&lt;/p&gt;选择器分组对选择器分组后，同一组内的选择器会分享相同的声明若一个选择器被凡在了多个组内，则会同时拥有每个组的样式，当样式冲突时，按规则选择样式继承问题大部分情况下会直接继承父亲的样式，但是可能会有浏览器兼容问题样式背景背景色可以使用background-color来设置背景色12345p &#123; background-color:blue; padding:20px; width: 400px;&#125;注意：background-color 不能继承背景图像可以使用background-image:来设置背景图片1234567p &#123; background-image:url(\"https://pic.cnblogs.com/avatar/1101696/20180214111459.png\"); background-repeat: none; padding:20px; width: 400px; height:800px;&#125;注意：不能继承背景重复使用background-repeat: repeat-x可以设置背景图片重复，repeat-x 和 repeat-y 分别导致图像只在水平或垂直方向上重复，no-repeat 则不允许图像在任何方向上平铺。1234567p &#123; background-image:url(\"https://pic.cnblogs.com/avatar/1101696/20180214111459.png\"); background-repeat: repeat-x; padding:20px; width: 400px; height:800px;&#125;背景定位background-position可以来设置图像位置可以选用center, top, bottom, left, right12345body &#123; background-image: url(\"http://wx4.sinaimg.cn/large/005S5cb6ly1fzaxhur5nwj3050050jrw.jpg\"); background-repeat: no-repeat; background-position: center;&#125;也可以直接用百分数值来定位下面的方式可以使元素放在水平方向 2/3、垂直方向 1/3 处12345body &#123; background-image:url('http://wx4.sinaimg.cn/large/005S5cb6ly1fzaxhur5nwj3050050jrw.jpg'); background-repeat:no-repeat; background-position:66% 33%;&#125;还可以设置长度12345body &#123; background-image:url('http://wx4.sinaimg.cn/large/005S5cb6ly1fzaxhur5nwj3050050jrw.jpg'); background-repeat:no-repeat; background-position:50px 100px;&#125;背景关联可以使用background-attachment来固定图片12345body &#123; background-image:url(/i/eg_bg_02.gif); background-repeat:no-repeat; background-attachment:fixed&#125;文本缩进文本可以使用text-indent: 5em来缩进文本可以使用负值来实现”悬挂缩进效果”，但是可能会超出浏览器边界，可以通过设置外边框和内边距来消除影响同样可以使用百分比值来缩进，百分数相对于缩进元素的父元素的宽度123p &#123; text-indent: 5em;&#125;水平对齐可以使用text-align:来实现文本对齐值 left、right 和 center 会导致元素中的文本分别左对齐、右对齐和居中。123p &#123; text-align : center;&#125;字符隔可以使用word-spacing : 2em来设置单词之间的标准间隔字母间隔可以使用letter-spacing: 2em来设置字母之间的间隔字符转换可以使用text-transform来设置大小写noneuppercaselowercasecapitalize默认值 none 对文本不做任何改动，将使用源文档中的原有大小写。顾名思义，uppercase 和 lowercase 将文本转换为全大写和全小写字符。最后，capitalize 只对每个单词的首字母大写。文本装饰文本的text-decoration属性可以实现对文本的装饰不过好像主流浏览器都不支持blink了。。none 去掉所有装饰underline 增加下划线overline 增加上划线？line-through 增加横穿线blink 使文本闪烁处理空白符可以使用white-space字体指定字体系列font-family可以自定义字体1h1 &#123;font-family: Georgia;&#125;字体风格font-style框模型定位选择器派生选择器派生选择器允许我们根据文档的上下文关系来确定某个标签的样式。例如12345h2 strong &#123; color: blue;&#125;&lt;strong&gt;233&lt;/strong&gt;&lt;h2&gt;123&lt;strong&gt;233&lt;/strong&gt;.&lt;/h2&gt;这样设置的话只有h2标签内的strong标签才会变蓝色id选择器id 选择器可以为标有特定id的HTML元素指定特定的样式。id 选择器以 “#” 来定义。id选择器常用来建立派生选择器,且可以定义多次效果：12345678910111213141516171819&lt;style&gt; #attack p &#123; color:blue &#125; #attack span &#123; font-size:23px; &#125; #attack &#123; color:pink; &#125;&lt;/style&gt;&lt;body&gt; &lt;div id = \"attack\"&gt; 123 &lt;p&gt;123&lt;/p&gt; &lt;span&gt;456&lt;/span&gt; &lt;/div&gt;&lt;/body&gt;注意：老版本的ie浏览器可能会忽略该规则，只需加一条定义就可以了1234div#sidebar &#123; border: 1px dotted #000; padding: 10px;&#125;类选择器类选择器通常用y一个点’.’来表示，它对整个class属性为ClassName的标签进行渲染class也可以构建派生选择器, 元素也可以基于它们的类而被选择(用于区分不同的标签)1.ClassName &#123;text-align: center&#125;12345678910111213141516&lt;style&gt; .attack p &#123; color:blue &#125; div.attack &#123; font-size:46px; &#125;&lt;/style&gt;&lt;body&gt; &lt;div class = \"attack\"&gt; &lt;p&gt;123&lt;/p&gt; &lt;span&gt;456&lt;/span&gt; &lt;/div&gt; &lt;p class = \"attack\"&gt;123&lt;/p&gt;&lt;/body&gt;注意：类名的第一个字符不能使用数字！属性选择器可以为拥有指定属性的 HTML 元素设置样式，而不仅限于 class 和 id 属性。下面的例子为带有 title 属性的所有元素设置样式：123[title] &#123; color:red;&#125;注意：只有在规定了 !DOCTYPE 时，IE7 和 IE8 才支持属性选择器。在 IE6 及更低的版本中，不支持属性选择。直接使用title选择器对p和a标签无效..(要你何用。)细节问题当值为若干个单词时记得加引号CSS本身对大小写并不敏感，但是当与HTML一起使用时对class和id的大小写敏感权重由大到小排列内联样式（在 HTML 元素内部）内部样式表（位于 &lt;head&gt; 标签内部）外部样式表浏览器缺省设置","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://attack204.com/categories/学习笔记/"}],"tags":[{"name":"css","slug":"css","permalink":"http://attack204.com/tags/css/"}]},{"title":"git使用小结","slug":"git使用小结","date":"2019-01-18T13:29:07.000Z","updated":"2019-01-19T02:11:41.555Z","comments":true,"path":"2019/01/18/git使用小结/","link":"","permalink":"http://attack204.com/2019/01/18/git使用小结/","excerpt":"记录一下，忘的太快了qwq","text":"记录一下，忘的太快了qwq首先需要弄好SSH，这一部分我早就弄好了，等以后需要重新弄的时候再更新吧上传方法1、首先进入文件夹，初始化工作目录1git init2、把文件都添加到暂存区中1git add .3、执行预提交命令1git commit -m '提交说明'4、关联到远程库git remote add origin 你的远程库地址远程仓库地址可以在这里获取5、获取远程库与本地同步合并（如果远程库不为空必须做这一步，否则后面的提交会失败）1git pull --rebase origin master6、把本地库的内容推送到远程，使用 git push命令实际上是把当前分支master推送到远程。执行此命令后会要求输入用户名、密码，验证通过后即开始上传。(如果配好ssh的话则不需要输入用户名密码)1git push -u origin master常见错误nothing to commit, working tree clean就是说没有什么可以更新的。。fatal: remote origin already exists.说明重复输入了第四步这时候只要输入git remote rm origin，再输入原命令就可以了常用命令参考资料如何用命令将本地项目上传到gitGit使用教程","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://attack204.com/categories/学习笔记/"}],"tags":[{"name":"git","slug":"git","permalink":"http://attack204.com/tags/git/"}]},{"title":"html学习笔记","slug":"html学习笔记","date":"2019-01-18T10:42:07.000Z","updated":"2019-01-19T04:34:23.962Z","comments":true,"path":"2019/01/18/html学习笔记/","link":"","permalink":"http://attack204.com/2019/01/18/html学习笔记/","excerpt":"html好神奇啊qwq记录一下颓的时候学的东西。","text":"html好神奇啊qwq记录一下颓的时候学的东西。标签body存放网站的主体内容p段落标签1&lt;p&gt;123 &lt;/p&gt;123hx标题文本一般分为6级1&lt;h1&gt; &lt;/h1&gt;123em, strong都可以表示强调内容。一般用strong多一些1&lt;strong&gt; &lt;/strong&gt;123spanspan是没有语义的，它的作用是为了设置单独样式qq标签是短文本应用标签网页会自动给其加上&quot;&quot;1&lt;q&gt; &lt;/q&gt;123blockquote长文本引用1&lt;blockquote&gt; &lt;/blockquote&gt;明月出天山，苍茫云海间。长风几万里，吹度玉门关。汉下白登道，胡窥青海湾。由来征战地，不见有人还。 戍客望边色，思归多苦颜。高楼当此夜，叹息未应闲。br分行标签一般写为&lt;br/&gt;， html4.01后可写为&lt;br&gt;1&lt;br&gt;&amp;nbsp 空格使用123```html&amp;nbsp&amp;nbsp &amp;nbsp &amp;nbsp &amp;nbsp 123 &amp;nbsphr添加水平横线html4.01版本12345xhtml1.0版本``` &lt;hr /&gt;````html&lt;hr&gt;address用于添加联系地址信息。默认为斜体1&lt;address&gt;联系地址信息&lt;/address&gt;联系地址信息codecode标签可以加入一行代码1&lt;code&gt;#include&lt;iostream&gt;&lt;/code&gt;#includeprepre标签可以插入大段代码12345678&lt;pre&gt;#include&lt;iostream&gt;using namespace std;int main() &#123; puts(\"GG\"); return 0;&#125;&lt;/pre&gt; #include using namespace std; int main() { puts(\"GG\"); return 0; } ulul为新闻信息列表，一般与li标签搭配使用ul标签默认没有先后顺序12345&lt;ul&gt; &lt;li&gt; a &lt;/li&gt; &lt;li&gt; b &lt;/li&gt; &lt;li&gt; c &lt;/li&gt;&lt;/ul&gt;abcolol标签与ul标签的区别在于ol标签有先后顺序12345&lt;ol&gt; &lt;li&gt; a &lt;/li&gt; &lt;li&gt; b &lt;/li&gt; &lt;li&gt; c &lt;/li&gt;&lt;/ol&gt;abcdivdiv标签应该是应用最广泛的标签，它可以把一些独立的逻辑部分划分出来，此时div标签充当了一个容器123&lt;div&gt; 123&lt;/div&gt;123tabletable可以展示表格内容其中又分为五个元素: table, tbody, tr, th, td1、&lt;table&gt;…&lt;/table&gt;：整个表格以&lt;table&gt;标记开始、&lt;/table&gt;标记结束。2、&lt;tbody&gt;…&lt;/tbody&gt;：如果不加&lt;thead&gt;&lt;tbody&gt;&lt;tfooter&gt; , table表格加载完后才显示。加上这些表格结构， tbody包含行的内容下载完优先显示，不必等待表格结束后在显示，同时如果表格很长，用tbody分段，可以一部分一部分地显示。（通俗理解table 可以按结构一块块的显示，不在等整个表格加载完后显示。）3、&lt;tr&gt;…&lt;/tr&gt;：表格的一行，所以有几对tr 表格就有几行。4、&lt;td&gt;…&lt;/td&gt;：表格的一个单元格，一行中包含几对&lt;td&gt;...&lt;/td&gt;，说明一行中就有几列。5、&lt;th&gt;…&lt;/th&gt;：表格的头部的一个单元格，表格表头。6、表格中列的个数，取决于一行中数据单元格的个数1234567891011121314151617&lt;table&gt; &lt;tr&gt; &lt;th&gt; 1 &lt;/th&gt; &lt;th&gt; 2 &lt;/th&gt; &lt;th&gt; 3 &lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; 1 &lt;/td&gt; &lt;td&gt; 2 &lt;/td&gt; &lt;td&gt; 3 &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; 4 &lt;/td&gt; &lt;td&gt; 5 &lt;/td&gt; &lt;td&gt; 6 &lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;123123456summary与captionsummary可以为表格提供摘要，摘要默认不显示caption可以为表格添加标题123456789101112131415161718&lt;table summary = \"test\"&gt; &lt;caption&gt; My table &lt;/caption&gt; &lt;tr&gt; &lt;th&gt; 1 &lt;/th&gt; &lt;th&gt; 2 &lt;/th&gt; &lt;th&gt; 3 &lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; 1 &lt;/td&gt; &lt;td&gt; 2 &lt;/td&gt; &lt;td&gt; 3 &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; 4 &lt;/td&gt; &lt;td&gt; 5 &lt;/td&gt; &lt;td&gt; 6 &lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;My table123123456aa标签可以实现超链接加入target = &quot;_blank&quot;可以实现在新标签页内打开在href使用mailto可以链接email地址12345&lt;a href=\"http://www.baidu.com\" title=\"鼠标滑过显示的文本\"&gt;链接显示的文本&lt;/a&gt;&lt;a href=\"http://www.baidu.com\" title=\"鼠标滑过显示的文本\" target = \"_blank\"&gt;链接显示的文本&lt;/a&gt;&lt;a href=\"mailto:757394026@qq.com\" title=\"鼠标滑过显示的文本\"&gt;在当前页面打开&lt;/a&gt;在新页面打开链接显示的文本链接邮件imgimg标签可以插入图片1&lt;img src=\"http://wx4.sinaimg.cn/mw690/005S5cb6ly1fzavtzhjpnj313o0fadg4.jpg\" alt=\"下载失败时的替换文本\" title = \"提示文本\"&gt;form表单标签表单可以把浏览者输入的数据传送到服务器端，这样服务器端程序就可以处理表单传过来的数据。&lt;form&gt; ：&lt;form&gt;标签是成对出现的，以&lt;form&gt;开始，以&lt;/form&gt;结束。2.action ：浏览者输入的数据被传送到的地方,比如一个PHP页面(save.php)。3.method ： 数据传送的方式（get/post）。注意:1、所有表单控件（文本框、文本域、按钮、单选框、复选框等）都必须放在标签之间（否则用户输入的信息可提交不到服务器上哦！）。2、method : post/get 的区别这一部分内容属于后端程序员考虑的问题。感兴趣的小伙伴可以查看本小节的 wiki，里面有详细介绍。12345678&lt;form method=\"传送方式\" action=\"服务器文件\"&gt;&lt;form method=\"post\" action=\"save.php\"&gt; &lt;label for=\"username\"&gt;用户名:&lt;/label&gt; &lt;input type=\"text\" name=\"username\" /&gt; &lt;label for=\"pass\"&gt;密码:&lt;/label&gt; &lt;input type=\"password\" name=\"pass\" /&gt;&lt;/form&gt;用户名:密码:label标签label标签不会向用户呈现任何特殊效果，它的作用是为鼠标用户改进了可用性。如果你在 label 标签内点击文本，就会触发此控件。就是说，当用户单击选中该label标签时，浏览器就会自动将焦点转到和标签相关的表单控件上（就自动选中和该label标签相关连的表单控件上）。12345678&lt;label for=\"控件id名称\"&gt;&lt;form&gt; 你对什么运动感兴趣？&lt;br&gt; &lt;label for=\"SlowRun\"&gt;慢跑&lt;/label&gt; &lt;input type=\"checkbox\" id=\"SlowRun\"/&gt; &lt;br&gt; &lt;label for=\"Climb\"&gt;登山&lt;/label&gt; &lt;input type=\"checkbox\" id=\"Climb\"/&gt; &lt;br&gt; &lt;label for=\"Basketball\"&gt;篮球&lt;/label&gt; &lt;br&gt;&lt;/form&gt;你对什么运动感兴趣？慢跑登山篮球input文本/密码输入框就是一个输入框，1、type：当type=”text”时，输入框为文本输入框;当type=”password”时, 输入框为密码输入框。2、name：为文本框命名，以备后台程序ASP 、PHP使用。3、value：为文本输入框设置默认值。(一般起到提示作用)123&lt;form&gt; &lt;input type=\"text/password\" name=\"名称\" value=\"文本\" /&gt;&lt;/form&gt;input提交按钮当用户需要提交表单信息到服务器时，需要用到提交按钮。type：只有当type值设置为submit时，按钮才有提交作用value：按钮上显示的文字1&lt;input type=\"submit\" value=\"提交\"&gt;input重置按钮重置按钮可以使表单内容恢复到最初始的样子12345&lt;form method = \"post\" action = \"save.php\"&gt; &lt;label for = \"myName\"&gt; 姓名：&lt;/label&gt; &lt;input type = \"text\" value = \"123\" name = \"myName\" /&gt; &lt;input type = \"reset\" value = \"重置\" name = resertBtn\"&gt;&lt;/form&gt;姓名：&lt;input type = “reset” value = “重置” name = resertBtn”&gt;input单选框，复选框就是单选框和复选框，以name属性来区分每一组。1、type:当 type=”radio” 时，控件为单选框当 type=”checkbox” 时，控件为复选框2、value：提交数据到服务器的值（后台程序PHP使用）3、name：为控件命名，以备后台程序 ASP、PHP 使用4、checked：当设置 checked=”checked” 时，该选项被默认选中1&lt;input type=\"radio/checkbox\" value=\"值\" name=\"名称\" checked=\"checked\"/&gt;textarea 文本域可以让用户输入大段文字1、&lt;textarea&gt;标签是成对出现的，以&lt;textarea&gt;开始，以&lt;/textarea&gt;结束。2、cols ：多行输入域的列数。3、rows ：多行输入域的行数。4、在&lt;textarea&gt;&lt;/textarea&gt;标签之间可以输入默认值。1234&lt;form method=\"post\" action=\"save.php\"&gt; &lt;label&gt;联系我们&lt;/label&gt; &lt;textarea cols=\"50\" rows=\"10\" &gt;在这里输入内容...&lt;/textarea&gt;&lt;/form&gt;联系我们在这里输入内容…select下拉列表框select标签可以实现一个下拉列表框1、value 是服务器提交的值2.、selected=”selected”：设置selected=”selected”属性，则该选项就被默认选中。3、在标签内设置= \"multiple```属性可以进行多选123456789101112```html&lt;form action=&quot;save.php&quot; method=&quot;post&quot; &gt; &lt;label&gt;爱好:&lt;/label&gt; &lt;!-- &lt;select multiple = &quot;multiple&quot;&gt; --&gt; &lt;select&gt; &lt;option value=&quot;看书&quot;&gt;看书&lt;/option&gt; &lt;option selected=&quot;selected&quot; value=&quot;旅游&quot;&gt;旅游&lt;/option&gt; &lt;option value=&quot;运动&quot;&gt;运动&lt;/option&gt; &lt;option value=&quot;购物&quot;&gt;购物&lt;/option&gt; &lt;/select&gt;&lt;/form&gt;爱好:看书旅游运动购物###1&lt;&gt;&lt;/&gt;&lt;&gt;&lt;/&gt;###1&lt;&gt;&lt;/&gt;&lt;&gt;&lt;/&gt;标签的属性分为全局属性和部分属性全局属性idid是规定元素的唯一id，每个元素的id必须是互不相同的","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://attack204.com/categories/学习笔记/"}],"tags":[{"name":"html","slug":"html","permalink":"http://attack204.com/tags/html/"}]},{"title":"Berlekamp-Massey算法学习笔记","slug":"Berlekamp-Massey算法学习笔记","date":"2018-12-11T13:40:07.000Z","updated":"2019-01-18T13:07:59.052Z","comments":true,"path":"2018/12/11/Berlekamp-Massey算法学习笔记/","link":"","permalink":"http://attack204.com/2018/12/11/Berlekamp-Massey算法学习笔记/","excerpt":"很久之前就听说过这个算法，当时六校联考的时候Day1T1是一道很有意思的递推，神仙zzx不会做于是就拿BM算法艹出了递推式Orzzzzzzzzzzx","text":"很久之前就听说过这个算法，当时六校联考的时候Day1T1是一道很有意思的递推，神仙zzx不会做于是就拿BM算法艹出了递推式Orzzzzzzzzzzx推荐一篇讲的详细的不能再详细的博客我就不详细说了，只记一下自己感觉比较难理解的地方设$r(m)$表示序列的递推式且长度为$m$$f(r, i)$表示$\\sum_{j = 1}^m r_j * a[i - j]$$\\delta(r, i)$表示$a[i] - f(r, i)$$fail_i$表示第$i$个递推式出错的位置对于某一个位置$i$，如果我们求出的$\\delta(r, i) \\not = 0$，这时候我们需要构造一个递推式$r’(m’)$，满足$\\forall j \\in [m’ + 1, i - 1] f(r’, j) = 0$且$f(r, i) = \\delta(r, i)$这样我们令$r = r + r’$就得到新位置的递推式了$r’$可以这么构造设$mul = \\frac{\\delta(r, i)}{\\delta(r, fail_{cnt - 1})}$那么$r’ = {0, 0, 0 \\dots, 0, mul, -mul * R_{cnt - 1} }$$0$的个数为$i - fail_{cnt - 1} - 1$至于为什么这么构造是对的，我思考了挺长时间，简单的证明一下首先对于$\\forall j \\in [m’ + 1, i - 1]$, $\\delta(r’, j) = 0$仔细想了想，，发现自己并不会证。。如果哪位大佬会的话可以教教本蒟蒻感性理解就是因为$r$在$[1, M]$处满足任意位置为$0$，然后右移一下还满足？。。至于为什么$f(r’, i) = \\delta(r, i)$可以这么考虑，前$i - fail_{cnt - 1} - 1$个位置产生的贡献为$0$$mul$产生的贡献为$mul * a_{fail_{cnt - 1}}$$-mul R_{cnt - 1}$产生的贡献为$-mul (a[fail_{cnt - 1}] - \\delta(r, fail_{cnt - 1]})$合并同类项后可以得到$mul * \\delta(r, fail_{cnt - 1}) = \\delta(r, i)$代码如下12345678910111213141516171819202122232425262728293031323334#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXN = 2005;const double eps = 1e-8;int cnt, fail[MAXN];double val[MAXN], delta[MAXN];vector &lt;double&gt; ans[MAXN];int main() &#123; int N; scanf(\"%d\", &amp;N); for (int i = 1; i &lt;= N; i++) scanf(\"%lf\", &amp;val[i]); for (int i = 1; i &lt;= N; i++) &#123; double tmp = val[i]; for (int j = 0; j &lt; ans[cnt].size(); j++) tmp -= ans[cnt][j] * val[i - j - 1]; delta[i] = tmp; if (fabs(tmp) &lt;= eps) continue; fail[cnt] = i; if (cnt == 0) &#123; ans[++cnt].resize(i); continue; &#125; double mul = delta[i] / delta[fail[cnt - 1]]; cnt++; ans[cnt].resize(i - fail[cnt - 2] - 1); ans[cnt].push_back(mul); for (int j = 0; j &lt; ans[cnt - 2].size(); j++) ans[cnt].push_back(ans[cnt - 2][j] * -mul); if (ans[cnt].size() &lt; ans[cnt - 1].size()) ans[cnt].resize(ans[cnt - 1].size()); for (int j = 0; j &lt; ans[cnt - 1].size(); j++) ans[cnt][j] += ans[cnt - 1][j]; &#125; for (int i = 0; i &lt; ans[cnt].size(); i++) cout &lt;&lt; ans[cnt][i] &lt;&lt; ' '; return 0;&#125;","categories":[{"name":"oi","slug":"oi","permalink":"http://attack204.com/categories/oi/"}],"tags":[{"name":"oi","slug":"oi","permalink":"http://attack204.com/tags/oi/"},{"name":"Berlekamp-Massey算法","slug":"Berlekamp-Massey算法","permalink":"http://attack204.com/tags/Berlekamp-Massey算法/"}]},{"title":"Yelee换用Gitalk评论系统","slug":"Yelee换用Gitalk评论系统","date":"2018-12-11T04:25:01.000Z","updated":"2018-12-11T04:37:27.012Z","comments":true,"path":"2018/12/11/Yelee换用Gitalk评论系统/","link":"","permalink":"http://attack204.com/2018/12/11/Yelee换用Gitalk评论系统/","excerpt":"嗯。。又换了个评论系统","text":"嗯。。又换了个评论系统步骤主要还是因为我比较懒，而且valine的后台是在太难弄了。所以还是换成了第三方的评论系统Gitalk首先在这里注册一个Github OAuth application在Yelee主题目录下的_config.yml中添加1234567gitalk: on: true clientID: 'your clientID' clientSecret: 'your clientSecret' repo: 'attack204.github.io' # 仓库地址 owner: 'attack204' # 拥有者 admin: ['attack204'] # admin 用户在_partial/comments下创建gitalk.ejs注意！下面的id选项中如果按照原式方法填的话会出现Error: Validation Failed的问题一个比较好的解决思路是直接填写id: &#39;&lt;%= page.title %&gt;&#39;12345678910111213141516&lt;section id='comments' style='margin: 2em; padding: 2em; background: rgba(255, 255, 255, 0.5)'&gt; &lt;link rel=\"stylesheet\" href=\"https://unpkg.com/gitalk/dist/gitalk.css\"&gt; &lt;script src=\"https://unpkg.com/gitalk@latest/dist/gitalk.min.js\"&gt;&lt;/script&gt; &lt;div id=\"gitalk-container\"&gt;&lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var gitalk = new Gitalk(&#123; clientID: '&lt;%= theme.gitalk.clientID %&gt;', clientSecret: '&lt;%= theme.gitalk.clientSecret %&gt;', repo: '&lt;%= theme.gitalk.repo %&gt;', owner: '&lt;%= theme.gitalk.owner %&gt;', admin: ['&lt;%= theme.gitalk.owner %&gt;'], id: window.location.pathname &#125;) gitalk.render('gitalk-container') &lt;/script&gt;&lt;/section&gt;修改 _partial/article.ejs123456789101112131415161718192021222324252627 &lt;% if (!index &amp;&amp; post.comments)&#123; %&gt; &lt;% if (theme.duoshuo.on) &#123; %&gt; &lt;%- partial('comments/duoshuo', &#123; key: post.path, title: post.title, url: config.url+url_for(post.path), &#125;) %&gt; &lt;% &#125; else if (theme.youyan.on) &#123; %&gt; &lt;%- partial('comments/youyan') %&gt; &lt;% &#125; else if (theme.disqus.on) &#123; %&gt; &lt;%- partial('comments/disqus', &#123; shortname: theme.disqus.shortname &#125;) %&gt; &lt;% &#125; else if (config.disqus_shortname) &#123; %&gt; &lt;%- partial('comments/disqus', &#123; shortname: config.disqus_shortname &#125;) %&gt; &lt;% &#125; else if (theme.valine.on) &#123; %&gt; &lt;%- partial('comments/valine', &#123; key: post.slug, title: post.title, url: config.url+url_for(post.path) &#125;) %&gt;+ &lt;% &#125; else if (theme.gitalk.on) &#123; %&gt;+ &lt;%- partial('comments/gitalk') %&gt; &lt;% &#125; %&gt;&lt;% &#125; %&gt;参考资料更换博客评论系统","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://attack204.com/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://attack204.com/tags/Hexo/"}]},{"title":"sublime实现markdown浏览器预览","slug":"sublime实现markdown浏览器预览","date":"2018-10-03T00:31:18.000Z","updated":"2018-10-03T05:33:47.315Z","comments":true,"path":"2018/10/03/sublime实现markdown浏览器预览/","link":"","permalink":"http://attack204.com/2018/10/03/sublime实现markdown浏览器预览/","excerpt":"利用sublime实现markdown浏览器预览","text":"利用sublime实现markdown浏览器预览效果预览实现首先下载插件OmniMarkupPreviewer方法：ctrl + shift + P安装完成后搜索’OmniMarkupPreviewer’双击即可下载完成后新建.md文件按’ctrl + Alt + O’即可在浏览器内预览注意这里可能会出现两个问题404打开浏览器后可能会出现404情况更改方法如下加入代码12345&#123; \"renderer_options-MarkdownRenderer\": &#123; \"extensions\": [\"tables\", \"fenced_code\", \"codehilite\"] &#125;&#125;Mathjax数学公式不支持打开把这里的’false’改为’true’，过一会儿重启sublime即可","categories":[],"tags":[{"name":"sublime","slug":"sublime","permalink":"http://attack204.com/tags/sublime/"}]},{"title":"sublime实现背景透明化","slug":"sublime实现背景透明化","date":"2018-10-03T00:01:18.000Z","updated":"2018-10-03T05:32:54.832Z","comments":true,"path":"2018/10/03/sublime实现背景透明化/","link":"","permalink":"http://attack204.com/2018/10/03/sublime实现背景透明化/","excerpt":"sublime不能自定义背景图片好气啊qwq","text":"sublime不能自定义背景图片好气啊qwq预览老司机们就不要吐槽背景图了实现方法首先下载插件，直接打包下载zip即可地址：https://github.com/vhanla/SublimeTextTrans下载完成后解压到packages目录然后就搞定了！可以按Shift + ctril + 1-6来实现不同的亮度控制如果觉得不合适的话可以去SublimeTextTrans.sublime-settings这个文件里更改值越小越透明","categories":[],"tags":[{"name":"sublime","slug":"sublime","permalink":"http://attack204.com/tags/sublime/"}]},{"title":"sublime实现一键代码格式化","slug":"sublime实现一键代码格式化","date":"2018-10-02T13:35:18.000Z","updated":"2018-10-03T05:33:58.594Z","comments":true,"path":"2018/10/02/sublime实现一键代码格式化/","link":"","permalink":"http://attack204.com/2018/10/02/sublime实现一键代码格式化/","excerpt":"用Astyle实现sublime代码一键格式化","text":"用Astyle实现sublime代码一键格式化效果预览实现首先下载插件SublimeAstyleFormatter方法：ctrl + shift + P后输入install Package。等待一段时间后输入SublimeAstyleFormatter即可自动下载使用方法按下ctrl + Alt + F是默认格式化整个文件按下ctrl + K + F即可格式化选中区域该插件中有许多不同的风格可以选择我比较习惯google代码风格，可以这样设置然后把第$28$行改为&quot;style&quot;: &quot;google&quot;, 完成！","categories":[],"tags":[{"name":"sublime","slug":"sublime","permalink":"http://attack204.com/tags/sublime/"}]},{"title":"关于本博客的说明","slug":"关于本博客的说明","date":"2018-04-30T12:30:03.000Z","updated":"2018-10-02T13:40:29.316Z","comments":true,"path":"2018/04/30/关于本博客的说明/","link":"","permalink":"http://attack204.com/2018/04/30/关于本博客的说明/","excerpt":"","text":"好久没有更新过这个博客了，因为本人实在太懒了QWQ。。不过今天实在是看不下去了，友言4.30就倒闭了，所以换了一个新的评论系统——valine，不得不说，这个评论系统是真的好用然后又优化了很多细节，比如右下角那个看板娘，不过我不知道怎么改样式啊QWQ…不管怎么改都是那一个小人，大小也没法改QWQ….至于博客内容的话，有空就更新吧，主要还是用博客园","categories":[],"tags":[]},{"title":"博弈论进阶之Multi-SG","slug":"博弈论进阶之Multi-SG","date":"2018-02-25T08:53:07.000Z","updated":"2018-02-25T08:55:56.516Z","comments":true,"path":"2018/02/25/博弈论进阶之Multi-SG/","link":"","permalink":"http://attack204.com/2018/02/25/博弈论进阶之Multi-SG/","excerpt":"Multi-Nim从最简单的Nim模型开始它的定义是这样的有$n$堆石子，两个人可以从任意一堆石子中拿任意多个石子(不能不拿)或把一堆数量不少于$2$石子分为两堆不为空的石子，没法拿的人失败。问谁会胜利","text":"Multi-Nim从最简单的Nim模型开始它的定义是这样的有$n$堆石子，两个人可以从任意一堆石子中拿任意多个石子(不能不拿)或把一堆数量不少于$2$石子分为两堆不为空的石子，没法拿的人失败。问谁会胜利博弈分析这个问题的本质还是Nim游戏，可以利用SG定理来解释通过观察不难不发现，操作一与普通的Nim游戏等价操作二实际上是将一个游戏分解为两个游戏，根据SG定理，我们可以通过异或运算把两个游戏连接到一起，作为一个后继状态煮个栗子SG(3)的后继状态有${ (0),(1),(2),(1,2) }$他们的SG值分别为${ 0,1,2,3 }$，因此$SG(3)=mex{ 0,1,2,3 }=4$另外这种游戏还有一个非常神奇的性质$$SG\\left( x\\right) =\\begin{cases}x-1\\left( x\\mod4=0\\right) \\ x\\left( x\\mod4=1 \\lor 2\\right) \\ x+1\\left( x\\mod4=3\\right) \\end{cases}$$然后把这个结论背过就好啦233Multi-SG根据上面的游戏，我们定义Multi-SG游戏Multi-SG 游戏规定，在符合拓扑原则的前提下，一个单一游戏的后继可以为多个单一游戏。Multi-SG其他规则与SG游戏相同。注意在这里要分清楚后继与多个单一游戏对于一个状态来说，不同的划分方法会产生多个不同的后继，而在一个后继中可能含有多个独立的游戏一个后继状态的SG值即为后继状态中独立游戏的异或和该状态的SG值即为后继状态的SG值中未出现过的最小值例题难度跨度好大啊QWQ。。直接放题解吧HDU 3032POJ 2311BZOJ 2940BZOJ 1188洛谷 3235","categories":[{"name":"oi","slug":"oi","permalink":"http://attack204.com/categories/oi/"}],"tags":[{"name":"oi","slug":"oi","permalink":"http://attack204.com/tags/oi/"},{"name":"博弈论","slug":"博弈论","permalink":"http://attack204.com/tags/博弈论/"},{"name":"Multi-SG","slug":"Multi-SG","permalink":"http://attack204.com/tags/Multi-SG/"}]},{"title":"博弈论入门之斐波那契博弈","slug":"博弈论入门之斐波那契博弈","date":"2018-02-25T02:03:11.000Z","updated":"2018-02-25T02:10:23.844Z","comments":true,"path":"2018/02/25/博弈论入门之斐波那契博弈/","link":"","permalink":"http://attack204.com/2018/02/25/博弈论入门之斐波那契博弈/","excerpt":"斐波那契博弈斐波那契博弈是一种经典的博弈问题有一堆石子，两个顶尖聪明的人玩游戏，先取者可以取走任意多个，但不能全取完，以后每人取的石子数不能超过上个人的两倍","text":"斐波那契博弈斐波那契博弈是一种经典的博弈问题有一堆石子，两个顶尖聪明的人玩游戏，先取者可以取走任意多个，但不能全取完，以后每人取的石子数不能超过上个人的两倍结论斐波那契博弈有一个非常重要的性质：先手必败，当且仅当石子数为斐波那契数是不是很神奇？？证明：懒得看了，这里有代码HDU 2516123456789101112#include&lt;cstdio&gt;#include&lt;map&gt;int fib[233],x;std::map&lt;int,bool&gt;mp;int main()&#123; fib[1]=1;fib[2]=1; for(int i=3;i&lt;=50;i++) fib[i]=fib[i-1]+fib[i-2],mp[fib[i]]=1; while(scanf(\"%d\",&amp;x)&amp;&amp;x!=0) puts(mp[x]==1?\"Second win\":\"First win\"); return 0;&#125;","categories":[{"name":"oi","slug":"oi","permalink":"http://attack204.com/categories/oi/"}],"tags":[{"name":"oi","slug":"oi","permalink":"http://attack204.com/tags/oi/"},{"name":"博弈论","slug":"博弈论","permalink":"http://attack204.com/tags/博弈论/"},{"name":"斐波那契博弈","slug":"斐波那契博弈","permalink":"http://attack204.com/tags/斐波那契博弈/"}]},{"title":"博弈论入门之威佐夫博弈","slug":"博弈论入门之威佐夫博弈","date":"2018-02-25T01:12:34.000Z","updated":"2018-02-25T01:14:22.828Z","comments":true,"path":"2018/02/25/博弈论入门之威佐夫博弈/","link":"","permalink":"http://attack204.com/2018/02/25/博弈论入门之威佐夫博弈/","excerpt":"威佐夫博弈威佐夫博弈是一类经典的博弈问题有两堆石子，两个顶尖聪明的人在玩游戏，每次每个人可以从任意一堆石子中取任意多的石子或者从两堆石子中取同样多的石子，不能取得人输，分析谁会获得胜利","text":"威佐夫博弈威佐夫博弈是一类经典的博弈问题有两堆石子，两个顶尖聪明的人在玩游戏，每次每个人可以从任意一堆石子中取任意多的石子或者从两堆石子中取同样多的石子，不能取得人输，分析谁会获得胜利博弈分析威佐夫博弈不同于Nim游戏与巴什博奕，它的特殊之处在于不能将两堆石子分开分析。前辈们在对该博弈游戏做了大量的探索之后最终找到了一些非常有意思的性质下面的内容不想看的可以跳过直接看结论，其实也没啥乱用233，这部分就是为了拓宽视野的定义先手必输的局势为奇异局势，前几个奇异局势为$(0,0),(1,2),(3,5),(4,7),(6,10) \\dots$假设$(x,y)$为第$k$个奇异局势性质：$x$为前$1 \\dots k$个奇异局势中没有出现过的最小正整数，$y=x+k$打表找规律任何一个自热数都包含在一个且仅有一个奇异局势中感觉网上证的都不靠谱，那只好本蒟蒻亲自下手喽证明这个结论，我们只需要证明两点:(1)任意自然数都出现过(2)任意自然数仅出现一次对于(1)：反证法，设$v$这个数没有出现过，那么$v$可以做一个新的奇异局势的$x$对于(2): 反证法假设数$v$出现了两次，那么$v$一定不是所在奇异局势的$x$($x$必须之前未出现)那么$v$只能同时是两个奇异局势的$y$，又因为任意一个奇异局势的差值不相同，因此$v$不可能出现两次任何操作都会将奇异局势变为非奇异局势若取走一堆中的石子，那么两对石子的差值会改变，必将成为非奇异局势若同时取走，因为同一个差值只会对应一种奇异局势，必将成为非奇异局势可以采取适当的方法将非奇异局势变为奇异局势显然结论人们通过对上述性质的探索，同时结合Betty定理，给出了威佐夫博弈的重要结论假设两堆石子为$(x,y)$（其中$x&lt;y$）那么先手必败，当且仅当$(y-x)*\\frac{(\\sqrt{5}+1)}{2}=x$其中的$\\frac{(\\sqrt{5}+1)}{2}$实际就是$1.618$，黄金分割数！怎么样，博弈论是不是很神奇？证明的话，首先你要会证明Betty定理，链接在上面，如果度娘的证明看不懂可以看这里威佐夫博弈结论的话可以看这里代码题目12345678910111213141516#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;#define int long long using namespace std;main()&#123; int a,b; scanf(\"%lld%lld\",&amp;a,&amp;b); if(a&gt;b) swap(a,b); int temp=abs(a-b); int ans=temp*(1.0+sqrt(5.0))/2.0; if(ans==a) printf(\"0\"); else printf(\"1\"); return 0;&#125;例题HDU 1527题解51NOD 1185题解","categories":[{"name":"oi","slug":"oi","permalink":"http://attack204.com/categories/oi/"}],"tags":[{"name":"oi","slug":"oi","permalink":"http://attack204.com/tags/oi/"},{"name":"博弈论","slug":"博弈论","permalink":"http://attack204.com/tags/博弈论/"},{"name":"威佐夫博弈","slug":"威佐夫博弈","permalink":"http://attack204.com/tags/威佐夫博弈/"}]},{"title":"博弈论进阶之Anti-SG游戏与SJ定理","slug":"博弈论进阶之Anti-SG游戏与SJ定理","date":"2018-02-24T00:16:27.000Z","updated":"2018-02-24T00:21:40.063Z","comments":true,"path":"2018/02/24/博弈论进阶之Anti-SG游戏与SJ定理/","link":"","permalink":"http://attack204.com/2018/02/24/博弈论进阶之Anti-SG游戏与SJ定理/","excerpt":"前言在上一节中，我们初步了解了一下SG函数与SG定理。今天我们来分析一下SG游戏的变式——Anti-SG游戏以及它所对应的SG定理","text":"前言在上一节中，我们初步了解了一下SG函数与SG定理。今天我们来分析一下SG游戏的变式——Anti-SG游戏以及它所对应的SG定理首先从最基本的Anti-Nim游戏开始Anti-Nim游戏是这样的有两个顶尖聪明的人在玩游戏，游戏规则是这样的：有$n$堆石子，两个人可以从任意一堆石子中拿任意多个石子(不能不拿)，拿走最后一个石子的人失败。问谁会胜利博弈分析Anti-Nim游戏与Nim游戏唯一的不同就是两人的胜利条件发生了改变，不过这并不影响我们对结论的推导对于这个游戏，先手必胜有两种情况当每堆石子都只有一个，且游戏的SG值为$0$至少一堆石子多于一个，且游戏的SG值不为$0$粗略的证明一下游戏大概可以被分为$3$种情况每堆只有一个石子当异或值为$0$时，先手必胜当异或值不为$0$时，先手必败只有一堆石子数大于1，先手必胜经过分析不难发现，先手可以对数量大于1的那堆石子下手脚，从而构造出后手必败的状态存在至少两堆石子数大于1当异或和为0时，先手必败当异或和不为0时，先手必败这一步的结论与Nim游戏非常相似，同时它们的证明也非常相似，大概就是从异或和为$0$的状态无论怎样都会变为异或和不为$0$的状态，反过来从异或和不为$0$的状态总有一步能到达异或和为$0$的状态推广按照我们学习SG函数的思路，我们是否可以把Anti-Nim游戏推广开来呢？答案是肯定的定义Anti-SG游戏Anti-SG游戏规定：决策集合为空的游戏者赢其余规则与SG游戏相同同时我们定义SJ定理对于Anti-SG游戏，如果我们规定当局面中所有单一游戏的SG值为0时，游戏结束，则先手必胜当且仅当(1)游戏的SG函数不为0且游戏中某个单一游戏的SG函数值大于1(2)游戏的SG函数为0且没有某个单一游戏的SG函数大于1证明与SG函数类似，不追求完美的可以从DAG上归纳追求完美的可以用模仿棋证明出该游戏的等价性然后推出该游戏是可数集合然后通过计算推出在模$2$意义下线性空间的基可以为$nim(0),nim(1)$最后归纳证明一个后继是若干Anti-nim游戏的游戏等价于$mex(S)$例题按照whx老师的说法Anti-SG不怎么重要，我至今为止就做到过一道题那道题在这儿题解","categories":[{"name":"oi","slug":"oi","permalink":"http://attack204.com/categories/oi/"}],"tags":[{"name":"oi","slug":"oi","permalink":"http://attack204.com/tags/oi/"},{"name":"博弈论","slug":"博弈论","permalink":"http://attack204.com/tags/博弈论/"},{"name":"Anti-SG","slug":"Anti-SG","permalink":"http://attack204.com/tags/Anti-SG/"},{"name":"SJ定理","slug":"SJ定理","permalink":"http://attack204.com/tags/SJ定理/"}]},{"title":"博弈论进阶之SG函数","slug":"博弈论进阶之SG函数","date":"2018-02-23T06:32:47.000Z","updated":"2018-02-23T06:46:41.904Z","comments":true,"path":"2018/02/23/博弈论进阶之SG函数/","link":"","permalink":"http://attack204.com/2018/02/23/博弈论进阶之SG函数/","excerpt":"SG函数个人理解：SG函数是人们在研究博弈论的道路上迈出的重要一步，它把许多杂乱无章的博弈游戏通过某种规则结合在了一起，使得一类普遍的博弈问题得到了解决。从SG函数开始，我们不再是单纯的同过找规律等方法去解决博弈问题，而是需要学习一些博弈论中基本的定理，来找到他们的共同特点","text":"SG函数个人理解：SG函数是人们在研究博弈论的道路上迈出的重要一步，它把许多杂乱无章的博弈游戏通过某种规则结合在了一起，使得一类普遍的博弈问题得到了解决。从SG函数开始，我们不再是单纯的同过找规律等方法去解决博弈问题，而是需要学习一些博弈论中基本的定理，来找到他们的共同特点那么就先介绍几个最基本的定理(也可以叫常识)吧基本定理ICG游戏1.游戏有两个人参与，二者轮流做出决策。且这两个人的决策都对自己最有利。2.当有一人无法做出决策时游戏结束，无法做出决策的人输。无论二者如何做出决策，游戏可以在有限步内结束。3.游戏中的同一个状态不可能多次抵达。且游戏不会有平局出现。任意一个游戏者在某一确定状态可以作出的决策集合只与当前的状态有关，而与游戏者无关。满足上述条件的问题我们称之为ICG游戏，ICG游戏属于组合游戏最典型的nim游戏，就是一种ICG游戏必胜态与必败态定义P-position与N-positionP-position：必败态(简记为P)，即Previous-position,你可以直观的认为处于这种状态的人一定会输N-position：必胜态(简记为N)，即Next-position，你可以直观的理解为处于这种状态的人一定会赢这仅仅是最直观的定义更严谨的定义为：无法移动的状态(即terminal-position)为P可以移动到P的局面为N所有移动都会进入N的局面为PDAG(有向无环图)中的博弈在正式研究$SG$函数之前，我们先来研究一下DAG中的博弈给定一张有向无环图，在起始定点有一枚棋子，两个顶尖聪明的人交替移动这枚棋子，不能移动的人算输不要小看这个游戏，事实上，所有ICG问题都可以抽象为这种游戏(即把初始局面看做顶点，把从一个状态可以到另一个状态之间连边)SG函数下面我们来正式研究一下SG(Sprague-Grundy)函数首先定义mex运算，这是一种集合中的运算，它表示最小的不属于集合的非负整数例如$mex{1,2,3}=0$，$mex{0,2}=1$，$mex{0,1,2,3}=4$，$mex{}=0$对于给定的有向无环图，定义每个点的SG函数为$SG(x)=mex {\\ SG(y)\\ |\\ x \\ can\\ go\\ to\\ y }$然而单单一个这样的空洞的函数是解决不了问题的，我们需要分析一下它的性质所有汇点的$SG$函数为$0$这个性质比较显然，因为汇点的所有后继状态都是空集当$SG(x)=0$时,该节点为必败点由$SG$函数的性质易知该节点的所有后继节点$SG$值均不为$0$满足必败态的定义当$SG(x)\\neq 0 $,该节点为必胜点由$SG$函数的定义可知该节点的后继节点中一定有一个节点$SG=0$满足必胜态的定义这样我们通过最基本的$SG$值的定义，我们就可以判断出一个状态是必胜态还是必败态这个问题实际上就是我们前面讲的巴什博奕如果这个问题再复杂一点呢？当这个棋盘上有$n$个棋子的时候呢？其实它们的分析思路是一样的当$SG(x)=k$时，它表明后继状态中含有$SG(y)=1 \\dots k-1$也就是说，我们从$k$可以转移到$1 \\dots k-1$中的任何一个状态，而当前共有$n$个棋子。这会让你想到什么？nim取石子游戏！那我们是不是也可以推出：如果在nim游戏中的$n$堆石子的$SG$值异或和不为$0$就说明先手必胜呢？这是肯定的，因为当你打出nim游戏的$SG$值表时就会发现，$SG_{nim}(x)=x$是不是很神奇？SG定理SG函数的应用远远不止和巴什博奕与nim游戏有关，我们回过头来考虑能否把SG函数推广开来类比nim取石子游戏的思路，我们可不可以大胆设想：游戏的和的SG值是他们的SG值的xor暂且不管这个结论对不对，我们设想一下，假如这个结论对的话，会有什么后果.我们可以将ICG问题对应到DAG上，然后直接通过SG函数之间的转移而解决几乎全部的问题是不是很令人兴奋？更令人兴奋的是，这个定理是正确的！什么？证明？如果你是一个追求完美的人可以看这里如果你像我一样连线性代数都不知道是什么的话大概就是从DAG上归纳一下就好了吧SG定理的应用SG定理的应用非常的广泛，几乎所有的博弈类问题都有它的影子，本文仅仅是简单的介绍一下这个定理，更深层次的应用以后会补充的上面提到了SG函数，那么SG函数的值是怎么计算的呢？很简单，我们直接通过$mex$运算的定义就可以计算了123456789101112131415int F[MAXN];//可以转移的状态集合，一般题目会给出 int S[MAXN];//表示该点可以转移到的状态有哪些 int SG[MAXN];//该点的SG值 void GetSG()&#123; for(int i=1;i&lt;=N;i++)//枚举DAG中所有点 &#123; memset(S,0,sizeof(S));//初始化 for(int j=1;j&lt;=limit&amp;&amp;F[j]&lt;=i;j++)//limit表示转移的集合的大小 S[SG[i-F[j]]]=1; for(int j=1;;j++) if(!S[j]) &#123;SG[i]=i;break;&#125;//根据定义计算SG函数 &#125;&#125;来一道裸题题解","categories":[{"name":"oi","slug":"oi","permalink":"http://attack204.com/categories/oi/"}],"tags":[{"name":"oi","slug":"oi","permalink":"http://attack204.com/tags/oi/"},{"name":"博弈论","slug":"博弈论","permalink":"http://attack204.com/tags/博弈论/"},{"name":"SG函数","slug":"SG函数","permalink":"http://attack204.com/tags/SG函数/"}]},{"title":"博弈论入门之nim游戏","slug":"博弈论入门之nim游戏","date":"2018-02-22T13:31:49.000Z","updated":"2018-02-23T06:46:20.919Z","comments":true,"path":"2018/02/22/博弈论入门之nim游戏/","link":"","permalink":"http://attack204.com/2018/02/22/博弈论入门之nim游戏/","excerpt":"nim游戏nim游戏有两个顶尖聪明的人在玩游戏，游戏规则是这样的：有$n$堆石子，两个人可以从任意一堆石子中拿任意多个石子(不能不拿)，没法拿的人失败。问谁会胜利","text":"nim游戏nim游戏有两个顶尖聪明的人在玩游戏，游戏规则是这样的：有$n$堆石子，两个人可以从任意一堆石子中拿任意多个石子(不能不拿)，没法拿的人失败。问谁会胜利nim游戏是巴什博奕的升级版(不懂巴什博奕的可以看这里)它不再是简单的一个状态，因此分析起来也棘手许多如果说巴什博奕仅仅博弈论的一个引子的话，nim游戏就差不多算是真正的入门了博弈分析面对新的博弈问题，我们按照套路，从简单的情况入手当只有一堆石子的时候，先手可以全部拿走。先手必胜当有两堆石子且石子个数相同的时候，先手不论拿多少，后手都可以从另一堆中拿同样多的石子，先手必败，否则先手必胜当有三堆的时候呢？当有$n$堆的时候呢？这样玩下去却是很繁琐，不过前辈们总结出了一条非常厉害的规律！定理解析定理对于nim游戏，前辈们发现了一条重要的规律！当$n$堆石子的数量异或和等于$0$时，先手必胜，否则先手必败证明设$\\oplus$表示异或运算nim游戏的必败态我们是知道的，就是当前$n$堆石子的数量都为零设$a[i]$表示第$i$堆石子的数量，那么当前局面就是$0 \\oplus 0 \\oplus 0 \\oplus \\dots \\oplus 0 = 0 $对于先手来说，如果当前局面是$a_1 \\oplus a_2 \\oplus a_3 \\oplus \\dots \\oplus a_n = k$那么一定存在某个$a_i$，它的二进制表示在$k$最高位上一定是$1$我们将$a_i \\oplus k$，这样就变成了$a_1 \\oplus a_2 \\oplus a_3 \\oplus \\dots \\oplus a_n \\oplus k = 0$此时先手必胜对于先手来说，如果当前局面是$a_1 \\oplus a_2 \\oplus a_3 \\oplus \\dots \\oplus a_n = k$那么我们不可能将某一个$a_i$异或一个数字后使得$a_1 \\oplus a_2 \\oplus a_3 \\oplus \\dots \\oplus a_n = 0$此时先手必败代码1234567891011121314151617#include&lt;cstdio&gt;using namespace std;int a[10001]; int main()&#123; int Test; scanf(\"%d\",&amp;Test); while(Test--) &#123; int ans=0,N; scanf(\"%d\",&amp;N); for(int i=1;i&lt;=N;i++) scanf(\"%d\",&amp;a[i]); for(int i=1;i&lt;=N;i++) ans=ans^a[i]; ans==0?printf(\"No\\n\"):printf(\"Yes\\n\"); &#125; return 0;&#125;题目临时还没有做太多题目，以后做多了慢慢补吧洛谷P2197题解POJ 1704估计没几个人能一眼秒吧233题解","categories":[{"name":"oi","slug":"oi","permalink":"http://attack204.com/categories/oi/"}],"tags":[{"name":"oi","slug":"oi","permalink":"http://attack204.com/tags/oi/"},{"name":"博弈论","slug":"博弈论","permalink":"http://attack204.com/tags/博弈论/"},{"name":"nim游戏","slug":"nim游戏","permalink":"http://attack204.com/tags/nim游戏/"}]},{"title":"博弈论入门之巴什博奕","slug":"博弈论入门之巴什博奕","date":"2018-02-22T12:21:50.000Z","updated":"2018-02-22T12:26:06.981Z","comments":true,"path":"2018/02/22/博弈论入门之巴什博奕/","link":"","permalink":"http://attack204.com/2018/02/22/博弈论入门之巴什博奕/","excerpt":"巴什博奕巴什博奕：两个顶尖聪明的人在玩游戏，有$n$个石子，每人可以随便拿$1-m$个石子，不能拿的人为败者，问谁会胜利巴什博奕是博弈论问题中基础的问题它是最简单的一种情形对应一种状态的博弈","text":"巴什博奕巴什博奕：两个顶尖聪明的人在玩游戏，有$n$个石子，每人可以随便拿$1-m$个石子，不能拿的人为败者，问谁会胜利巴什博奕是博弈论问题中基础的问题它是最简单的一种情形对应一种状态的博弈博弈分析我们从最简单的情景开始分析当石子有$1-m$个时，毫无疑问，先手必胜当石子有$m+1$个时，先手无论拿几个，后手都可以拿干净，先手必败当石子有$m+2-2m$时，先手可以拿走几个，剩下$m+1$个，先手必胜我们不难发现，面临$m+1$个石子的人一定失败。这样的话两个人的最优策略一定是通过拿走石子，使得对方拿石子时还有$m+1$个我们考虑往一般情况推广设当前的石子数为$n=k*(m+1)+r$先手会首先拿走$r$个，接下来假设后手拿走$x$个，先手会拿走$m+1-k$个，这样博弈下去后手最终一定失败设当前的石子数为$n=k*(m+1)$假设先手拿$x$个，后手一定会拿$m+1-x$个，这样下去先手一定失败代码123456789#include&lt;cstdio&gt;int main()&#123; int n,m; scanf(\"%d%d\",&amp;n,&amp;m); if(n % (m+1) !=0) printf(\"first win\"); else printf(\"second win\"); return 0;&#125;题目HDU1846题解HDU4764题解HDU1847题解","categories":[{"name":"oi","slug":"oi","permalink":"http://attack204.com/categories/oi/"}],"tags":[{"name":"oi","slug":"oi","permalink":"http://attack204.com/tags/oi/"},{"name":"博弈论","slug":"博弈论","permalink":"http://attack204.com/tags/博弈论/"},{"name":"巴什博奕","slug":"巴什博奕","permalink":"http://attack204.com/tags/巴什博奕/"}]},{"title":"树链剖分","slug":"树链剖分","date":"2018-02-22T00:49:23.000Z","updated":"2018-02-22T00:50:14.078Z","comments":true,"path":"2018/02/22/树链剖分/","link":"","permalink":"http://attack204.com/2018/02/22/树链剖分/","excerpt":"树链剖分是什么？树链剖分，说白了就是一种让你代码不得不强行增加1k的数据结构-dms有什么用？证明出题人非常毒瘤可以非常友(bao)好(li)的解决一些树上问题","text":"树链剖分是什么？树链剖分，说白了就是一种让你代码不得不强行增加1k的数据结构-dms有什么用？证明出题人非常毒瘤可以非常友(bao)好(li)的解决一些树上问题核心思想树链剖分的思想比较神奇它的思想是：把一棵树拆成若干个不相交的链，然后用一些数据结构去维护这些链那么问题来了如何把树拆成链？首先明确一些定义重儿子：该节点的子树中,节点个数最多的子树的根节点(也就是和该节点相连的点)，即为该节点的重儿子重边：连接该节点与它的重儿子的边重链：由一系列重边相连得到的链轻链：由一系列非重边相连得到的链这样就不难得到拆树的方法对于每一个节点，找出它的重儿子，那么这棵树就自然而然的被拆成了许多重链与许多轻链如何对这些链进行维护？首先，要对这些链进行维护，就要确保每个链上的节点都是连续的，因此我们需要对整棵树进行重新编号，然后利用dfs序的思想，用线段树或树状数组等进行维护（具体用什么需要看题目要求，因为线段树的功能比树状数组强大，所以在这里我就不提供树状数组的写法了）注意在进行重新编号的时候先访问重链这样可以保证重链内的节点编号连续上面说的太抽象了，结合一张图来理解一下对于一棵最基本的树给他标记重儿子，蓝色为重儿子，红色为重边然后对树进行重新编号橙色表示的是该节点重新编号后的序号不难看出重链内的节点编号是连续的然后就可以在线段树上搞事情啦像什么区间加区间求和什么的另外有一个性质：以$i$为根的子树的树在线段树上的编号为$[i,i+子树节点数-1]$接下来结合一道例题，加深一下对于代码的理解代码首先来一坨定义1234int deep[MAXN];//节点的深度 int fa[MAXN];//节点的父亲 int son[MAXN];//节点的重儿子 int tot[MAXN];//节点子树的大小第一步按照我们上面说的，我们首先要对整棵树dfs一遍，找出每个节点的重儿子顺便处理出每个节点的深度，以及他们的父亲节点1234567891011121314int dfs1(int now,int f,int dep)&#123; deep[now]=dep; fa[now]=f; tot[now]=1; int maxson=-1; for(int i=head[now];i!=-1;i=edge[i].nxt) &#123; if(edge[i].v==f) continue; tot[now]+=dfs1(edge[i].v,now,dep+1); if(tot[edge[i].v]&gt;maxson) maxson=tot[edge[i].v],son[now]=edge[i].v; &#125; return tot[now];&#125;第二步然后我们需要对整棵树进行重新编号我把一开始的每个节点的权值存在了$b$数组内1234567891011void dfs2(int now,int topf)&#123; idx[now]=++cnt; a[cnt]=b[now]; top[now]=topf; if(!son[now]) return ; dfs2(son[now],topf); for(int i=head[now];i!=-1;i=edge[i].nxt) if(!idx[edge[i].v]) dfs2(edge[i].v,edge[i].v);&#125;$idx$表示重新编号后该节点的编号是多少另外，这里引入了一个$top$数组，$top[i]$表示$i$号节点所在重链的头节点(最顶上的节点)至于这个数组有啥用，后面再说第三步我们需要根据重新编完号的树，把这棵树的上每个点映射到线段树上，1234567891011121314151617struct Tree&#123; int l,r,w,siz,f;&#125;T[MAXN];void Build(int k,int ll,int rr)&#123; T[k].l=ll;T[k].r=rr;T[k].siz=rr-ll+1; if(ll==rr) &#123; T[k].w=a[ll]; return ; &#125; int mid=(ll+rr)&gt;&gt;1; Build(ls,ll,mid); Build(rs,mid+1,rr); update(k);&#125;另外线段树的基本操作，这里就不详细解释了直接放代码1234567891011121314151617181920212223242526272829303132333435363738void update(int k)//更新&#123; T[k].w=(T[ls].w+T[rs].w+MOD)%MOD;&#125;void IntervalAdd(int k,int ll,int rr,int val)//区间加&#123; if(ll&lt;=T[k].l&amp;&amp;T[k].r&lt;=rr) &#123; T[k].w+=T[k].siz*val; T[k].f+=val; return ; &#125; pushdown(k); int mid=(T[k].l+T[k].r)&gt;&gt;1; if(ll&lt;=mid) IntervalAdd(ls,ll,rr,val); if(rr&gt;mid) IntervalAdd(rs,ll,rr,val); update(k);&#125;int IntervalSum(int k,int ll,int rr)//区间求和&#123; int ans=0; if(ll&lt;=T[k].l&amp;&amp;T[k].r&lt;=rr) return T[k].w; pushdown(k); int mid=(T[k].l+T[k].r)&gt;&gt;1; if(ll&lt;=mid) ans=(ans+IntervalSum(ls,ll,rr))%MOD; if(rr&gt;mid) ans=(ans+IntervalSum(rs,ll,rr))%MOD; return ans;&#125;void pushdown(int k)//下传标记&#123; if(!T[k].f) return ; T[ls].w=(T[ls].w+T[ls].siz*T[k].f)%MOD; T[rs].w=(T[rs].w+T[rs].siz*T[k].f)%MOD; T[ls].f=(T[ls].f+T[k].f)%MOD; T[rs].f=(T[rs].f+T[k].f)%MOD; T[k].f=0;&#125;第四步我们考虑如何实现对于树上的操作树链剖分的思想是:对于两个不在同一重链内的节点,让他们不断地跳,使得他们处于同一重链上那么如何”跳”呢？还记得我们在第二次$dfs$中记录的$top$数组么？有一个显然的结论：$x$到$top[x]$中的节点在线段树上是连续的，结合$deep$数组假设两个节点为$x$,$y$我们每次让$deep[top[x]]$与$deep[top[y]]$中大的(在下面的)往上跳(有点类似于树上倍增)让x节点直接跳到$top[x]$,然后在线段树上更新最后两个节点一定是处于同一条重链的，前面我们提到过重链上的节点都是连续的，直接在线段树上进行一次查询就好123456789101112131415161718192021222324void TreeSum(int x,int y)//x与y路径上的和&#123; int ans=0; while(top[x]!=top[y]) &#123; if(deep[top[x]]&lt;deep[top[y]]) swap(x,y); ans=(ans+IntervalSum(1,idx[ top[x] ],idx[x]))%MOD; x=fa[ top[x] ]; &#125; if(deep[x]&gt;deep[y]) swap(x,y); ans=(ans+IntervalSum(1,idx[x],idx[y]))%MOD; printf(\"%d\\n\",ans);&#125;void TreeAdd(int x,int y,int val)//对于x,y路径上的点加val的权值&#123; while(top[x]!=top[y]) &#123; if(deep[top[x]]&lt;deep[top[y]]) swap(x,y); IntervalAdd(1,idx[ top[x] ],idx[x],val); x=fa[ top[x] ]; &#125; if(deep[x]&gt;deep[y]) swap(x,y); IntervalAdd(1,idx[x],idx[y],val);&#125;在树上查询的这一步可能有些抽象，我们结合一个例子来理解一下还是上面那张图，假设我们要查询$3.6$这两个节点的之间的点权合，为了方便理解我们假设每个点的点权都是$1$刚开始时$top[3]=2,top[6]=1$$deep[top[3]]=2,deep[top[6]]=1$我们会让$3$向上跳,跳到$top[3]$的爸爸,也就是$1$号节点这时$1$号节点和$6$号节点已经在同一条重链内,所以直接对线段树进行一次查询即可对于子树的操作这个就更简单了因为一棵树的子树在线段树上是连续的所以修改的时候直接这样IntervalAdd(1,idx[x],idx[x]+tot[x]-1,z%MOD);时间复杂度性质1如果边$\\left( u,v\\right)$,为轻边,那么$Size\\left( v\\right) \\leq Size\\left( u\\right) /2$。证明：显然，否则该边会成为重边性质2树中任意两个节点之间的路径中轻边的条数不会超过$\\log _{2}n$,重路径的数目不会超过$\\log _{2}n$证明：不会有了上面两条性质，我们就可以来分析时间复杂度了由于重路径的数量的上界为$\\log _{2}n$，线段树中查询/修改的复杂度为$\\log _{2}n$那么总的复杂度就是$\\left( \\log _{2}n\\right) ^{2}$完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;const int MAXN=2*1e6+10;#define ls k&lt;&lt;1#define rs k&lt;&lt;1|1inline char nc()&#123; static char buf[MAXN],*p1=buf,*p2=buf; return p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,MAXN,stdin),p1==p2)?EOF:*p1++;&#125;inline int read()&#123; char c=nc();int x=0,f=1; while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=nc();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0',c=nc();&#125; return x*f;&#125;struct node&#123; int u,v,nxt;&#125;edge[MAXN];int head[MAXN];int num=1;struct Tree&#123; int l,r,w,siz,f;&#125;T[MAXN];int N,M,root,MOD,cnt=0,a[MAXN],b[MAXN];inline void AddEdge(int x,int y)&#123; edge[num].u=x; edge[num].v=y; edge[num].nxt=head[x]; head[x]=num++;&#125;int deep[MAXN],fa[MAXN],son[MAXN],tot[MAXN],top[MAXN],idx[MAXN];int dfs1(int now,int f,int dep)&#123; deep[now]=dep; fa[now]=f; tot[now]=1; int maxson=-1; for(int i=head[now];i!=-1;i=edge[i].nxt) &#123; if(edge[i].v==f) continue; tot[now]+=dfs1(edge[i].v,now,dep+1); if(tot[edge[i].v]&gt;maxson) maxson=tot[edge[i].v],son[now]=edge[i].v; &#125; return tot[now];&#125;void update(int k)&#123; T[k].w=(T[ls].w+T[rs].w+MOD)%MOD;&#125;void Build(int k,int ll,int rr)&#123; T[k].l=ll;T[k].r=rr;T[k].siz=rr-ll+1; if(ll==rr) &#123; T[k].w=a[ll]; return ; &#125; int mid=(ll+rr)&gt;&gt;1; Build(ls,ll,mid); Build(rs,mid+1,rr); update(k);&#125;void dfs2(int now,int topf)&#123; idx[now]=++cnt; a[cnt]=b[now]; top[now]=topf; if(!son[now]) return ; dfs2(son[now],topf); for(int i=head[now];i!=-1;i=edge[i].nxt) if(!idx[edge[i].v]) dfs2(edge[i].v,edge[i].v);&#125;void pushdown(int k)&#123; if(!T[k].f) return ; T[ls].w=(T[ls].w+T[ls].siz*T[k].f)%MOD; T[rs].w=(T[rs].w+T[rs].siz*T[k].f)%MOD; T[ls].f=(T[ls].f+T[k].f)%MOD; T[rs].f=(T[rs].f+T[k].f)%MOD; T[k].f=0;&#125;void IntervalAdd(int k,int ll,int rr,int val)&#123; if(ll&lt;=T[k].l&amp;&amp;T[k].r&lt;=rr) &#123; T[k].w+=T[k].siz*val; T[k].f+=val; return ; &#125; pushdown(k); int mid=(T[k].l+T[k].r)&gt;&gt;1; if(ll&lt;=mid) IntervalAdd(ls,ll,rr,val); if(rr&gt;mid) IntervalAdd(rs,ll,rr,val); update(k);&#125;void TreeAdd(int x,int y,int val)&#123; while(top[x]!=top[y]) &#123; if(deep[top[x]]&lt;deep[top[y]]) swap(x,y); IntervalAdd(1,idx[ top[x] ],idx[x],val); x=fa[ top[x] ]; &#125; if(deep[x]&gt;deep[y]) swap(x,y); IntervalAdd(1,idx[x],idx[y],val);&#125;int IntervalSum(int k,int ll,int rr)&#123; int ans=0; if(ll&lt;=T[k].l&amp;&amp;T[k].r&lt;=rr) return T[k].w; pushdown(k); int mid=(T[k].l+T[k].r)&gt;&gt;1; if(ll&lt;=mid) ans=(ans+IntervalSum(ls,ll,rr))%MOD; if(rr&gt;mid) ans=(ans+IntervalSum(rs,ll,rr))%MOD; return ans;&#125;void TreeSum(int x,int y)&#123; int ans=0; while(top[x]!=top[y]) &#123; if(deep[top[x]]&lt;deep[top[y]]) swap(x,y); ans=(ans+IntervalSum(1,idx[ top[x] ],idx[x]))%MOD; x=fa[ top[x] ]; &#125; if(deep[x]&gt;deep[y]) swap(x,y); ans=(ans+IntervalSum(1,idx[x],idx[y]))%MOD; printf(\"%d\\n\",ans);&#125;int main()&#123; #ifdef WIN32 freopen(\"a.in\",\"r\",stdin); #else #endif memset(head,-1,sizeof(head)); N=read();M=read();root=read();MOD=read(); for(int i=1;i&lt;=N;i++) b[i]=read(); for(int i=1;i&lt;=N-1;i++) &#123; int x=read(),y=read(); AddEdge(x,y);AddEdge(y,x); &#125; dfs1(root,0,1); dfs2(root,root); Build(1,1,N); while(M--) &#123; int opt=read(),x,y,z; if(opt==1) &#123; x=read();y=read();z=read();z=z%MOD; TreeAdd(x,y,z); &#125; else if(opt==2) &#123; x=read();y=read(); TreeSum(x,y); &#125; else if(opt==3) &#123; x=read(),z=read(); IntervalAdd(1,idx[x],idx[x]+tot[x]-1,z%MOD); &#125; else if(opt==4) &#123; x=read(); printf(\"%d\\n\",IntervalSum(1,idx[x],idx[x]+tot[x]-1)); &#125; &#125; return 0;&#125;","categories":[{"name":"oi","slug":"oi","permalink":"http://attack204.com/categories/oi/"}],"tags":[{"name":"oi","slug":"oi","permalink":"http://attack204.com/tags/oi/"},{"name":"树链剖分","slug":"树链剖分","permalink":"http://attack204.com/tags/树链剖分/"}]},{"title":"次小生成树","slug":"次小生成树","date":"2018-02-21T13:55:45.000Z","updated":"2018-02-21T14:18:39.563Z","comments":true,"path":"2018/02/21/次小生成树/","link":"","permalink":"http://attack204.com/2018/02/21/次小生成树/","excerpt":"我们已经熟知了求最小生成树的方法，用kruskal,prim算法都可以搞那么我们如何求次小生成树呢？这里次小生成树的定义是边权和严格大于最小生成树的边权和最小的生成树","text":"我们已经熟知了求最小生成树的方法，用kruskal,prim算法都可以搞那么我们如何求次小生成树呢？这里次小生成树的定义是边权和严格大于最小生成树的边权和最小的生成树次小生成树次小生成树我们已经熟知了求最小生成树的方法，用kruskal,prim算法都可以搞那么我们如何求次小生成树呢？这里次小生成树的定义是边权和严格大于最小生成树的边权和最小的生成树求解方法次小生成树嘛，肯定和最小生成树脱不了关系那么我们首先求出最小生成树接下来，一个比较显然的思路是枚举每一条未加入最小生成树的边，加入最小生成树，同时在最小生成树中删除边权最大的边如果你想到了这里并写出了代码，那么恭喜你你在里成功还有一步之遥成功掉进坑里了比如下面的例子蓝边表示最小生成树中的边，黄边表示新加入的边在这种情况下，如果仅仅记录最大值的话，得到的答案一定是错的所以我们还要记录严格小于最大值的最大值当产生冲突的时候我们需要删除严格小于最大值的最大值优化但是这样效率太低了，每一次查询都是$O(n)$的有没有更好的方法呢？不要忘了，最小生成树它是一棵树呀树的链上最大最小值操作，你想到了什么？没错！树上倍增我们在倍增的过程中记录下最大值和严格小于最大值的最大值这样每次查询的复杂度就变成$log(n)$啦总结流程整个算法的流程大概是求出最小生成树构造出倍增数组每次树上倍增查询时间复杂度用kruskal是$O(m\\log m+Q\\log (n))$用prim是$O(n\\log n+Q\\log (n))$Q为询问次数代码放一道裸题123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161// luogu-judger-enable-o2#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;iostream&gt;#define int long long using namespace std;const int MAXN=400001;const int INF=1e15+10;inline int read()&#123; char c=getchar();int x=0,f=1; while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; return x*f;&#125;struct Edge&#123; int u,v,w;&#125;E[MAXN];int Enum=1;void Add(int x,int y,int z)&#123; E[Enum].u=x; E[Enum].v=y; E[Enum].w=z;Enum++;&#125;struct node&#123; int u,v,w,nxt;&#125;edge[MAXN];int head[MAXN];int num=1;int N,M;int fa[MAXN],vis[MAXN],sum;int deep[MAXN],f[MAXN][21],maxx[MAXN][21],minx[MAXN][21];void AddEdge(int x,int y,int z)&#123; edge[num].u=x; edge[num].v=y; edge[num].w=z; edge[num].nxt=head[x]; head[x]=num++;&#125;int find(int x)&#123; if(fa[x]==x) return fa[x]; else return fa[x]=find(fa[x]);&#125;int unionn(int x,int y)&#123; int fx=find(x),fy=find(y); fa[fx]=fy;&#125;int comp(const Edge &amp;a,const Edge &amp;b)&#123; return a.w&lt;b.w;&#125;void Kruskal()&#123; sort(E+1,E+Enum,comp); int tot=0; for(int i=1;i&lt;=Enum-1;i++) &#123; int x=E[i].u,y=E[i].v; if(find(x)!=find(y)) &#123; unionn(x,y),tot++,sum+=E[i].w,vis[i]=1; AddEdge(x,y,E[i].w);AddEdge(y,x,E[i].w); &#125; if(tot==N-1) break; &#125;&#125;void dfs(int now,int fa)&#123; for(int i=head[now];i!=-1;i=edge[i].nxt) &#123; if(edge[i].v==fa) continue; deep[edge[i].v]=deep[edge[i].u]+1; f[edge[i].v][0]=now; maxx[edge[i].v][0]=edge[i].w; dfs(edge[i].v,now); &#125;&#125;void pre()&#123; for(int i=1;i&lt;=18;i++) &#123; for(int j=1;j&lt;=N;j++) &#123; f[j][i]=f[ f[j][i-1] ][i-1]; maxx[j][i]=max(maxx[j][i-1],maxx[ f[j][i-1] ][i-1]); minx[j][i]=max(minx[j][i-1],minx[ f[j][i-1] ][i-1]); if(maxx[j][i-1]&gt;maxx[ f[j][i-1] ][i-1]) minx[j][i]=max(minx[j][i],maxx[ f[j][i-1] ][i-1]); else minx[j][i]=max(minx[j][i],maxx[j][i-1]); &#125; &#125;&#125;int LCA(int x,int y)&#123; if(deep[x]&lt;deep[y]) swap(x,y); for(int i=18;i&gt;=0;i--) if(deep[ f[x][i] ] &gt;= deep[y] ) x=f[x][i]; if(x==y) return x; for(int i=18;i&gt;=0;i--) if(f[x][i] != f[y][i]) x=f[x][i],y=f[y][i]; return f[x][0];&#125;int findmax(int x,int lca,int val)&#123; int ans=0; for(int i=18;i&gt;=0;i--) &#123; if(deep[ f[x][i] ] &gt;= deep[lca]) &#123; if(maxx[x][i]==val) ans=max(ans,minx[x][i]); else ans=max(ans,maxx[x][i]); x=f[x][i]; &#125; &#125; return ans;&#125;void work()&#123; int ans=INF; for(int i=1;i&lt;=Enum-1;i++) &#123; if(vis[i]) continue; int x=E[i].u,y=E[i].v,z=E[i].w; int lca=LCA(x,y); int lmx=findmax(x,lca,z); int rmx=findmax(y,lca,z); if(max(lmx,rmx)!=z) ans=min(ans,sum+z-max(lmx,rmx)); &#125; printf(\"%lld\",ans);&#125;main()&#123; #ifdef WIN32 freopen(\"a.in\",\"r\",stdin); #else #endif N=read(),M=read(); memset(head,-1,sizeof(head)); for(int i=1;i&lt;=N;i++) fa[i]=i; for(int i=1;i&lt;=M;i++) &#123; int x=read(),y=read(),z=read(); Add(x,y,z); &#125; Kruskal(); deep[1]=1; dfs(1,0); pre(); work(); return 0; &#125;","categories":[{"name":"oi","slug":"oi","permalink":"http://attack204.com/categories/oi/"}],"tags":[{"name":"oi","slug":"oi","permalink":"http://attack204.com/tags/oi/"},{"name":"最小生成树","slug":"最小生成树","permalink":"http://attack204.com/tags/最小生成树/"}]},{"title":"MatrixTree速成","slug":"MatrixTree速成","date":"2018-02-21T11:10:18.000Z","updated":"2018-02-21T11:20:44.600Z","comments":true,"path":"2018/02/21/MatrixTree速成/","link":"","permalink":"http://attack204.com/2018/02/21/MatrixTree速成/","excerpt":"MatrixTree定理是用来解决生成树计数问题的有利工具比如说这道题MatrixTree定理的算法流程也非常简单我们记矩阵$A$为无向图的度数矩阵记矩阵$D$为无向图的邻接矩阵","text":"MatrixTree定理是用来解决生成树计数问题的有利工具比如说这道题MatrixTree定理的算法流程也非常简单我们记矩阵$A$为无向图的度数矩阵记矩阵$D$为无向图的邻接矩阵前言MatrixTree定理是用来解决生成树计数问题的有利工具比如说这道题MatrixTree定理的算法流程也非常简单我们记矩阵$A$为无向图的度数矩阵记矩阵$D$为无向图的邻接矩阵$A$矩阵是除了对角线之外各个点值都为$0$的矩阵，$A[i][i]$表示$i$号点的度数$D$矩阵记录两点之间的度数，$D[i][j]$表示$i$号点与$j$号点之间的边数MatrixTree定理我们记矩阵$G=A-D$那么$G$的所有不同生成树的个数等于$G$的任何一个 $n-1$ 阶主子式的行列式的绝对值实现MatrixTree定理的实现非常简单计算出$D$矩阵后对其进行高斯消元把消元后的矩阵的对角线乘起来输出代码就是上面那道题目的代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;using namespace std;const int MAXN=3001;const double eps=1e-12;inline int read()&#123; char c=getchar();int x=0,f=1; while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; return x*f;&#125;double G[MAXN][MAXN],a[MAXN][MAXN];char s[MAXN][MAXN];int xx[5]=&#123;0,-1,+1,0,0&#125;;int yy[5]=&#123;0,0,0,-1,+1&#125;;int N,M;int dcmp(int x)&#123; if(x&lt;=eps||x&gt;=-eps) return 0; else return x&lt;0?-1:1;&#125;void Gauss()&#123; N--; for(int i=1;i&lt;=N;i++)//每一行 &#123; int mx=i; for(int j=i+1;j&lt;=N;j++)//下面的每一行 if(dcmp(G[mx][i]-G[j][i])&lt;0) mx=j; if(mx!=i) swap(G[i],G[mx]); if(!G[i][i]) &#123;printf(\"0\\n\");return ;&#125; for(int j=i+1;j&lt;=N;j++) &#123; double t=G[j][i]/G[i][i]; for(int k=i;k&lt;=N+1;k++) G[j][k]-=t*G[i][k]; &#125; &#125; double ans=1; for(int i=1;i&lt;=N;i++) ans=ans*G[i][i]; printf(\"%.0f\\n\",abs(ans));&#125;int main()&#123; int T=read(); while(T--) &#123; memset(G,0,sizeof(G)); N=read(),M=read(); for(int i=1;i&lt;=M;i++) &#123; int x=read(),y=read(); G[x][x]++;G[y][y]++; G[x][y]--;G[y][x]--; &#125; Gauss(); &#125; return 0; &#125;","categories":[],"tags":[{"name":"oi","slug":"oi","permalink":"http://attack204.com/tags/oi/"},{"name":"线性代数","slug":"线性代数","permalink":"http://attack204.com/tags/线性代数/"},{"name":"MatrixTree定理","slug":"MatrixTree定理","permalink":"http://attack204.com/tags/MatrixTree定理/"}]},{"title":"四边形不等式优化DP","slug":"四边形不等式优化DP","date":"2018-02-20T12:08:47.000Z","updated":"2018-02-21T11:47:46.225Z","comments":true,"path":"2018/02/20/四边形不等式优化DP/","link":"","permalink":"http://attack204.com/2018/02/20/四边形不等式优化DP/","excerpt":"记录一下，以免忘了对于一个形如$$dp[i][j]=min(dp[i][k]+dp[k][j]+w[i][j])$$的转移方程（注意取最大值时不一定满足四边形不等式）","text":"记录一下，以免忘了对于一个形如$$dp[i][j]=min(dp[i][k]+dp[k][j]+w[i][j])$$的转移方程（注意取最大值时不一定满足四边形不等式）记录一下，以免忘了首先对于一个形如$$dp[i][j]=min(dp[i][k]+dp[k][j]+w[i][j])$$的转移方程（注意取最大值时不一定满足四边形不等式）定理1若对于$a \\leq b\\leq c \\leq d$且$w_{b,c}\\leq w_{a,d}$那么我们称$w$关于区间包含关系单调定理2若对于$a \\leq b\\leq c \\leq d$且$w_{a,c}+w_{b,d}\\leq w_{b,c}+w_{a,d}$则称$w$满足四边形不等式性质1若$w$满足四边形不等式，当且仅当$w_{i,j}+w_{i+1,j+1}\\leq w_{i+1,j}+w_{i,j+1}$（没啥卵用）性质2若$w$满足四边形不等式，且关于区间包含关系单调则$dp$也满足四边形不等式性质3设$s_{i,j}$为$dp_{i,j}$的决策点，若$dp$满足四边形不等式那么$s_{i,j-1}\\leq s_{i,j} \\leq s_{i+1,j}$证明放一个不错的博客例题石子归并加强版其实这题并不是极限数据，再强一点的可以去百度SDOI2008石子归并，据说要用平衡树维护某G姓算法123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;cstdio&gt;#include&lt;cstring&gt;const int MAXN=1e5+10,INF=1e8+10;using namespace std;inline char nc()&#123; static char buf[MAXN],*p1=buf,*p2=buf; return p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,MAXN,stdin)),p1==p2?EOF:*p1++;&#125;inline int read()&#123; char c=nc();int x=0,f=1; while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=nc();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=nc();&#125; return x*f;&#125;int dp[3001][3001],sum[MAXN],s[3001][3001];int main()&#123; #ifdef WIN32 freopen(\"a.in\",\"r\",stdin); #else #endif int N=read(); for(int i=1;i&lt;=N;i++) sum[i]=read(),sum[i]+=sum[i-1],s[i][i]=i; for(int i=N;i&gt;=1;i--) &#123; for(int j=i+1;j&lt;=N;j++) &#123; int mn=INF,mnpos=0; for(int k=s[i][j-1];k&lt;=s[i+1][j];k++) &#123; if(dp[i][k]+dp[k+1][j]+sum[j]-sum[i-1] &lt; mn) &#123; mn=dp[i][k]+dp[k+1][j]+sum[j]-sum[i-1]; mnpos=k; &#125; &#125; dp[i][j]=mn; s[i][j]=mnpos; &#125; &#125; printf(\"%d\",dp[1][N]); return 0;&#125;","categories":[],"tags":[{"name":"DP优化","slug":"DP优化","permalink":"http://attack204.com/tags/DP优化/"},{"name":"四边形不等式","slug":"四边形不等式","permalink":"http://attack204.com/tags/四边形不等式/"}]},{"title":"debug","slug":"test","date":"2018-02-20T10:56:45.000Z","updated":"2018-02-22T01:48:08.188Z","comments":true,"path":"2018/02/20/test/","link":"","permalink":"http://attack204.com/2018/02/20/test/","excerpt":"测试文章+","text":"测试文章+1234# 一级标题## 二级标题### 三级标题#### 四级标题一级标题二级标题三级标题四级标题123&gt; 每段开头加&gt;可以引用&gt;&gt; 加两个就是嵌套引用&gt;&gt;&gt; 我真的还想再套八百年每段开头加&gt;可以引用加两个就是嵌套引用我真的还想再套八百年1234*我想变弯***我想变胖**集齐三颗星就能召唤分割线，三个-也可以***我想变胖集齐三颗星就能召唤分割线，三个-也可以12要输入特殊符号就在前面加\\我不想\\*变弯\\*，只想露点\\***要输入特殊符号就在前面加\\我不想*变弯*，只想露点***12每行开头空四格就能把文字变红并框起来，就像这样或者用大键盘数字1左边的那个`符号引住也可以每行开头空四格就能把文字变红并框起来，就像这样或者用大键盘数字1左边的那个`符号引住也可以1`妈妈`再也不用担心我输入不了`代码`啦妈妈再也不用担心我输入不了代码啦1234无序列表功能：人生三大错觉- 手机响了- 有人敲门- Ta喜欢我无序列表功能：人生三大错觉手机响了有人敲门Ta喜欢我1234有序列表功能：人生新三大错觉1. 忙完这几天就能轻松了2. 假期可以干很多有意义的事3. 看完这个我就去睡觉有序列表功能：人生新三大错觉忙完这几天就能轻松了假期可以干很多有意义的事看完这个我就去睡觉","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2018-01-01T11:10:18.000Z","updated":"2018-02-22T12:28:49.200Z","comments":true,"path":"2018/01/01/hello-world/","link":"","permalink":"http://attack204.com/2018/01/01/hello-world/","excerpt":"","text":"本版本仅适用于Win环境本文关键字： Hexo绿色版，Hexo便携版，Hexo配置，Hexo，U盘Hexo是一个快速、简洁且高效的博客框架，支持 GitHub Flavored Markdown 的所有功能；具有超快生成速度，让上百个页面在几秒内瞬间完成渲染；还拥有各式各样的插件等等。但是就像很多教程里面写的那样，搭建 Hexo 本地环境，需要安装 Node.js、Git 以及使用 npm 进行安装和配置。这对于毫无经验的新手来说，是一个很大的挑战。同时，由于这些环境的存在，导致如果需要更换计算机的时候，重新安装配置一个新的Hexo环境，又得花费一些功夫。所以呢，锵锵，我们整合了一个 Hexo 便携版，来简化本地环境的部署。####版本介绍那么所谓的便携版到底是什么？便携版就是将 Hexo 本地环境所需要的各种依赖环境的整合到一起，做成的不需要安装的版本。本便携版（Release 1.0.0）所包含的软件如下：Git: 2.7.4Nodejs: 6.10.1Npm: 4.4.1Hexo: 3.2.2为了便携的需要，不能配置固定的环境变量，所以除此之外还有相应的批处理文件，下文将详细介绍。####从零开始，1分钟搭建Hexo写作环境说了这么多，我们这就开始教你如何在1分钟内，从零开始搭建Hexo写作环境！#####1 注册一个Github帐号1.1 进入Github，并在右边的3个框框中分别填写 用户名、邮箱地址、账户密码，并点击 Sign up for Github;1.2 进入欢迎页面后，点击Finish sign up;1.3 进入到这一步之后（图1.3.1），先别记着点任何东西，查看你的邮箱，应该会收到如下的邮件（图1.3.2），确认你的邮件。否则，你会看到错误页面（图1.3.3）。query完毕之后在图1.3.1所示的页面，点击+ New repository;1.4 请在红框中的 Repository name 里面输入 用户名.github.io ( 用户名 就是你刚刚 步骤1.1 中注册的用户名)，然后点击 Create repository;1.5 至此，Github网页注册的部分完毕####2 下载HEXO Portable2.1 访问我们的 HEXO Portable 页面，或者 Github仓库 下载最新的便携版；2.2 双击得到的自解压文件，解压到你需要安装博客的地方，可以选择硬盘或者U盘；####3 配置你的环境3.1 在你的博客的文件夹，你会发现很多批处理文件，我先介绍下各个文件的用途：配置基本信息 &gt;&gt; 配置博客的基本环境配置Github部署 &gt;&gt; 配置博客的部署启动命令行 &gt;&gt; 启动带环境变量的Git-Bash，否则无法使用node、npm、git等命令新建文章 &gt;&gt; 新建一篇文章渲染并本地测试 &gt;&gt; 生成并本地预览渲染并部署 &gt;&gt; 生成并部署到GitHub重置配置文件 &gt;&gt; 重置_config.yml3.2 我们继续进行环境配置，双击配置基本信息并按顺序输入以下信息：主标题：顾名思义副标题：顾名思义描述：顾名思义作者：顾名思义网站地址：填写 用户名.github.io （此处的用户名为步骤1.1中填写的用户名）如果您已经购买了域名，可以参看相关的文章！3.3 双击配置Github部署并按顺序输入以下信息：Github的用户名：此处的用户名为步骤1.1中填写的用户名Github注册邮箱：此处的注册邮箱为步骤1.1中填写的注册邮箱3.4 输入完毕之后，会进行测试部署，等待屏幕提示下面将进行部署测试，稍后将有一个openssh的对话框出现，请输入你的github用户密码。的时候，按回车继续；（此处的用户密码为步骤1.1中填写的用户密码）3.5 然后继续等待，此时屏幕会出现n多行，耐心等待即可；3.6 等待屏幕提示请访问 https://用户名.github.io 查看是否部署成功！的时候，在浏览器中输入https://用户名.github.io ，理论上可以看到你的Hexo站点！（此处的用户名为步骤1.1中填写的用户名）3.7 至此，你的Hexo环境就配置完成了，这样你的这个Hexo博客文件夹无论移动到哪一台电脑，都能通过启动命令行出现的bash命令行，或者其余便捷的批处理文件比如新建文章、渲染并本地测试、渲染并部署进行相应的操作。3.8 如果你在配置中出错，可以运行重置配置文件后，再重复3.1~3.6步骤####4 开始享受纯粹的Hexo写作吧！####5 备注本便携版以及本文均使用 CC BY-NC-SA 4.0协议；本文所有权归 QistChan &amp; Bitmoe Inc. 所有；本便携版由 Bitmoe Inc. 维护并提供技术支持；需要技术支持可以在Github仓库 提交Issues；Written with StackEdit.","categories":[],"tags":[]}]}